--- a/include/stdlib.h
+++ b/include/stdlib.h
@@ -631,15 +631,13 @@
 #endif
 
 #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
-/* Return the canonical absolute name of file NAME.  The last file name
-   component need not exist, and may be a symlink to a nonexistent file.
-   If RESOLVED is null, the result is malloc'd; otherwise, if the canonical
-   name is PATH_MAX chars or more, returns null with `errno' set to
-   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars, returns the
-   name in RESOLVED.  */
-/* we choose to handle __resolved==NULL as crash :) */
+/* Return the canonical absolute name of file NAME.  If RESOLVED is
+   null, the result is malloc'd; otherwise, if the canonical name is
+   PATH_MAX chars or more, returns null with `errno' set to
+   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
+   returns the name in RESOLVED.  */
 extern char *realpath (__const char *__restrict __name,
-		       char *__restrict __resolved) __THROW __wur __nonnull((2));
+		       char *__restrict __resolved) __THROW __wur;
 #endif
 
 
--- a/libc/stdlib/realpath.c
+++ b/libc/stdlib/realpath.c
@@ -21,9 +21,6 @@
 
 #include <sys/stat.h>			/* for S_IFLNK */
 
-/* Experimentally off - libc_hidden_proto(strcat) */
-/* Experimentally off - libc_hidden_proto(strcpy) */
-/* Experimentally off - libc_hidden_proto(strlen) */
 libc_hidden_proto(readlink)
 libc_hidden_proto(getcwd)
 
@@ -41,19 +38,10 @@
 
 #define MAX_READLINKS 32
 
-#ifdef __STDC__
 char *realpath(const char *path, char got_path[])
-#else
-char *realpath(path, got_path)
-const char *path;
-char got_path[];
-#endif
 {
 	char copy_path[PATH_MAX];
-	/* use user supplied buffer directly - reduces stack usage */
-	/* char got_path[PATH_MAX]; */
-	char *max_path;
-	char *new_path;
+	char *max_path, *new_path, *allocated_path;
 	size_t path_len;
 	int readlinks = 0;
 #ifdef S_IFLNK
@@ -77,12 +65,13 @@
 	/* Copy so that path is at the end of copy_path[] */
 	strcpy(copy_path + (PATH_MAX-1) - path_len, path);
 	path = copy_path + (PATH_MAX-1) - path_len;
+	allocated_path = got_path ? NULL : (got_path = malloc(PATH_MAX));
 	max_path = got_path + PATH_MAX - 2; /* points to last non-NUL char */
 	new_path = got_path;
 	if (*path != '/') {
 		/* If it's a relative pathname use getcwd for starters. */
 		if (!getcwd(new_path, PATH_MAX - 1))
-			return NULL;
+			goto err;
 		new_path += strlen(new_path);
 		if (new_path[-1] != '/')
 			*new_path++ = '/';
@@ -119,6 +108,8 @@
 		while (*path != '\0' && *path != '/') {
 			if (new_path > max_path) {
 				__set_errno(ENAMETOOLONG);
+ err:
+				free(allocated_path);
 				return NULL;
 			}
 			*new_path++ = *path++;
@@ -127,7 +118,7 @@
 		/* Protect against infinite loops. */
 		if (readlinks++ > MAX_READLINKS) {
 			__set_errno(ELOOP);
-			return NULL;
+			goto err;
 		}
 		path_len = strlen(path);
 		/* See if last (so far) pathname component is a symlink. */
@@ -138,13 +129,13 @@
 			if (link_len < 0) {
 				/* EINVAL means the file exists but isn't a symlink. */
 				if (errno != EINVAL) {
-					return NULL;
+					goto err;
 				}
 			} else {
 				/* Safe sex check. */
 				if (path_len + link_len >= PATH_MAX - 2) {
 					__set_errno(ENAMETOOLONG);
-					return NULL;
+					goto err;
 				}
 				/* Note: readlink doesn't add the null byte. */
 				/* copy_path[link_len] = '\0'; - we don't need it too */
