--- iproute2/ip/ip6tunnel.c
+++ iproute2/ip/ip6tunnel.c
@@ -47,6 +47,7 @@
 
 #define DEFAULT_TNL_HOP_LIMIT	(64)
 
+#ifdef NO_OPTSIZE
 static void usage(void) __attribute__((noreturn));
 
 static void usage(void)
@@ -67,6 +68,9 @@ static void usage(void)
 	fprintf(stderr, "       FL   := { 0x0..0xfffff | inherit }\n");
 	exit(-1);
 }
+#else
+#define usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 static void print_tunnel(struct ip6_tnl_parm *p)
 {
@@ -237,7 +241,9 @@ static int do_tunnels_list(struct ip6_tn
 	int err = -1;
 	FILE *fp = fopen("/proc/net/dev", "r");
 	if (fp == NULL) {
+#ifdef NO_OPTSIZE
 		perror("fopen");
+#endif
 		goto end;
 	}
 
@@ -258,7 +264,9 @@ static int do_tunnels_list(struct ip6_tn
 		buf[sizeof(buf) - 1] = '\0';
 		if ((ptr = strchr(buf, ':')) == NULL ||
 		    (*ptr++ = 0, sscanf(buf, "%s", name) != 1)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Wrong format of /proc/net/dev. Sorry.\n");
+#endif
 			goto end;
 		}
 		if (sscanf(ptr, "%ld%ld%ld%ld%ld%ld%ld%*d%ld%ld%ld%ld%ld%ld%ld",
@@ -271,7 +279,9 @@ static int do_tunnels_list(struct ip6_tn
 			continue;
 		type = tnl_ioctl_get_iftype(name);
 		if (type == -1) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Failed to get type of [%s]\n", name);
+#endif
 			continue;
 		}
 		if (type != ARPHRD_TUNNEL6)
@@ -362,7 +372,9 @@ int do_ip6tunnel(int argc, char **argv)
 	case AF_INET6:
 		break;
 	default:
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Unsupported family:%d\n", preferred_family);
+#endif
 		exit(-1);
 	}
 
@@ -382,6 +394,8 @@ int do_ip6tunnel(int argc, char **argv)
 	} else
 		return do_show(0, NULL);
 
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Command \"%s\" is unknown, try \"ip -f inet6 tunnel help\".\n", *argv);
+#endif
 	exit(-1);
 }
--- iproute2/ip/ipaddress.c
+++ iproute2/ip/ipaddress.c
@@ -53,6 +53,7 @@ static struct
 
 static int do_link;
 
+#ifdef NO_OPTSIZE
 static void usage(void) __attribute__((noreturn));
 
 static void usage(void)
@@ -79,6 +80,9 @@ static void usage(void)
 
 	exit(-1);
 }
+#else
+#define usage(a) exit(-1)
+#endif /* NO_OPTSIZE */
 
 void print_link_flags(FILE *fp, unsigned flags, unsigned mdown)
 {
@@ -159,7 +163,9 @@ int print_linkinfo(const struct sockaddr
 
 	parse_rtattr(tb, IFLA_MAX, IFLA_RTA(ifi), len);
 	if (tb[IFLA_IFNAME] == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "BUG: nil ifname\n");
+#endif
 		return -1;
 	}
 	if (filter.label &&
@@ -278,7 +284,9 @@ int print_linkinfo(const struct sockaddr
 static int flush_update(void)
 {
 	if (rtnl_send(&rth, filter.flushb, filter.flushp) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Failed to send flush request\n");
+#endif
 		return -1;
 	}
 	filter.flushp = 0;
@@ -309,7 +317,9 @@ int print_addrinfo(const struct sockaddr
 		return 0;
 	len -= NLMSG_LENGTH(sizeof(*ifa));
 	if (len < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "BUG: wrong nlmsg len %d\n", len);
+#endif
 		return -1;
 	}
 
@@ -534,11 +544,15 @@ int ipaddr_list_or_flush(int argc, char
 
 	if (flush) {
 		if (argc <= 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Flush requires arguments.\n");
+#endif
 			return -1;
 		}
 		if (filter.family == AF_PACKET) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Cannot flush link addresses.\n");
+#endif
 			return -1;
 		}
 	}
@@ -603,19 +617,25 @@ int ipaddr_list_or_flush(int argc, char
 	}
 
 	if (rtnl_wilddump_request(&rth, preferred_family, RTM_GETLINK) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot send dump request");
+#endif
 		exit(1);
 	}
 
 	if (rtnl_dump_filter(&rth, store_nlmsg, &linfo, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Dump terminated\n");
+#endif
 		exit(1);
 	}
 
 	if (filter_dev) {
 		filter.ifindex = ll_name_to_index(filter_dev);
 		if (filter.ifindex <= 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Device \"%s\" does not exist.\n", filter_dev);
+#endif
 			return -1;
 		}
 	}
@@ -630,17 +650,23 @@ int ipaddr_list_or_flush(int argc, char
 
 		for (;;) {
 			if (rtnl_wilddump_request(&rth, filter.family, RTM_GETADDR) < 0) {
+#ifdef NO_OPTSIZE
 				perror("Cannot send dump request");
+#endif
 				exit(1);
 			}
 			filter.flushed = 0;
 			if (rtnl_dump_filter(&rth, print_addrinfo, stdout, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Flush terminated\n");
+#endif
 				exit(1);
 			}
 			if (filter.flushed == 0) {
 				if (round == 0) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "Nothing to flush.\n");
+#endif
 				} else if (show_stats)
 					printf("*** Flush is complete after %d round%s ***\n", round, round>1?"s":"");
 				fflush(stdout);
@@ -659,12 +685,16 @@ int ipaddr_list_or_flush(int argc, char
 
 	if (filter.family != AF_PACKET) {
 		if (rtnl_wilddump_request(&rth, filter.family, RTM_GETADDR) < 0) {
+#ifdef NO_OPTSIZE
 			perror("Cannot send dump request");
+#endif
 			exit(1);
 		}
 
 		if (rtnl_dump_filter(&rth, store_nlmsg, &ainfo, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Dump terminated\n");
+#endif
 			exit(1);
 		}
 	}
@@ -885,21 +915,27 @@ int ipaddr_modify(int cmd, int flags, in
 		argc--; argv++;
 	}
 	if (d == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not enough information: \"dev\" argument is required.\n");
+#endif
 		return -1;
 	}
 	if (l && matches(d, l) != 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "\"dev\" (%s) must match \"label\" (%s).\n", d, l);
+#endif
 		exit(1);
 	}
 
 	if (peer_len == 0 && local_len) {
 		if (cmd == RTM_DELADDR && lcl.family == AF_INET && !(lcl.flags & PREFIXLEN_SPECIFIED)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr,
 			    "Warning: Executing wildcard deletion to stay compatible with old scripts.\n" \
 			    "         Explicitly specify the prefix length (%s/%d) to avoid this warning.\n" \
 			    "         This special behaviour is likely to disappear in further releases,\n" \
 			    "         fix your scripts!\n", lcl_arg, local_len*8);
+#endif
 		} else {
 			peer = lcl;
 			addattr_l(&req.n, sizeof(req), IFA_ADDRESS, &lcl.data, lcl.bytelen);
@@ -912,7 +948,9 @@ int ipaddr_modify(int cmd, int flags, in
 		inet_prefix brd;
 		int i;
 		if (req.ifa.ifa_family != AF_INET) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Broadcast can be set only for IPv4 addresses\n");
+#endif
 			return -1;
 		}
 		brd = peer;
@@ -933,17 +971,23 @@ int ipaddr_modify(int cmd, int flags, in
 	ll_init_map(&rth);
 
 	if ((req.ifa.ifa_index = ll_name_to_index(d)) == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Cannot find device \"%s\"\n", d);
+#endif
 		return -1;
 	}
 
 	if (valid_lftp || preferred_lftp) {
 		if (!valid_lft) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "valid_lft is zero\n");
+#endif
 			return -1;
 		}
 		if (valid_lft < preferred_lft) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "preferred_lft is greater than valid_lft\n");
+#endif
 			return -1;
 		}
 
@@ -978,9 +1022,11 @@ int do_ipaddr(int argc, char **argv)
 		return ipaddr_list_or_flush(argc-1, argv+1, 0);
 	if (matches(*argv, "flush") == 0)
 		return ipaddr_list_or_flush(argc-1, argv+1, 1);
+#ifdef NO_OPTSIZE
 	if (matches(*argv, "help") == 0)
 		usage();
 	fprintf(stderr, "Command \"%s\" is unknown, try \"ip address help\".\n", *argv);
+#endif
 	exit(-1);
 }
 
--- iproute2/ip/ip.c
+++ iproute2/ip/ip.c
@@ -38,6 +38,7 @@ char *batch_file = NULL;
 int force = 0;
 struct rtnl_handle rth = { .fd = -1 };
 
+#ifdef NO_OPTSIZE
 static void usage(void) __attribute__((noreturn));
 
 static void usage(void)
@@ -57,6 +58,9 @@ static int do_help(int argc, char **argv
 {
 	usage();
 }
+#else
+#define usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 static const struct cmd {
 	const char *cmd;
@@ -73,10 +77,14 @@ static const struct cmd {
 	{ "link",	do_iplink },
 	{ "tunnel",	do_iptunnel },
 	{ "tunl",	do_iptunnel },
+#ifdef NO_OPTSIZE
 	{ "monitor",	do_ipmonitor },
 	{ "xfrm",	do_xfrm },
+#endif
 	{ "mroute",	do_multiroute },
+#ifdef NO_OPTSIZE
 	{ "help",	do_help },
+#endif
 	{ 0 }
 };
 
@@ -89,7 +97,9 @@ static int do_cmd(const char *argv0, int
 			return c->func(argc-1, argv+1);
 	}
 
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Object \"%s\" is unknown, try \"ip help\".\n", argv0);
+#endif
 	return -1;
 }
 
@@ -98,18 +108,24 @@ static int batch(const char *name)
 	char *line = NULL;
 	size_t len = 0;
 	int ret = 0;
+#ifdef NO_OPTSIZE
 	int lineno = 0;
+#endif
 
 	if (name && strcmp(name, "-") != 0) {
 		if (freopen(name, "r", stdin) == NULL) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Cannot open file \"%s\" for reading: %s=n",
 				name, strerror(errno));
+#endif
 			return -1;
 		}
 	}
 
 	if (rtnl_open(&rth, 0) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Cannot open rtnetlink\n");
+#endif
 		return -1;
 	}
 
@@ -122,7 +138,9 @@ static int batch(const char *name)
 			continue;	/* blank line */
 
 		if (do_cmd(largv[0], largc, largv)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Command failed %s:%d\n", name, lineno);
+#endif
 			ret = 1;
 			if (!force)
 				break;
@@ -212,7 +230,9 @@ int main(int argc, char **argv)
 		} else if (matches(opt, "-help") == 0) {
 			usage();
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Option \"%s\" is unknown, try \"ip -help\".\n", opt);
+#endif
 			exit(-1);
 		}
 		argc--;	argv++;
--- iproute2/ip/iplink.c
+++ iproute2/ip/iplink.c
@@ -32,6 +32,7 @@
 #include "ip_common.h"
 
 
+#ifdef NO_OPTSIZE
 static void usage(void) __attribute__((noreturn));
 
 void iplink_usage(void)
@@ -55,10 +56,16 @@ static void usage(void)
 {
 	iplink_usage();
 }
+#else
+#define usage() exit(-1)
+#define iplink_usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 static int on_off(char *msg)
 {
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Error: argument of \"%s\" must be \"on\" or \"off\"\n", msg);
+#endif
 	return -1;
 }
 
@@ -78,7 +85,9 @@ static int get_ctl_fd(void)
 	if (fd >= 0)
 		return fd;
 	errno = s_errno;
+#ifdef NO_OPTSIZE
 	perror("Cannot create control socket");
+#endif
 	return -1;
 }
 
@@ -94,7 +103,9 @@ static int do_chflags(const char *dev, _
 		return -1;
 	err = ioctl(fd, SIOCGIFFLAGS, &ifr);
 	if (err) {
+#ifdef NO_OPTSIZE
 		perror("SIOCGIFFLAGS");
+#endif
 		close(fd);
 		return -1;
 	}
@@ -102,8 +113,10 @@ static int do_chflags(const char *dev, _
 		ifr.ifr_flags &= ~mask;
 		ifr.ifr_flags |= mask&flags;
 		err = ioctl(fd, SIOCSIFFLAGS, &ifr);
+#ifdef NO_OPTSIZE
 		if (err)
 			perror("SIOCSIFFLAGS");
+#endif
 	}
 	close(fd);
 	return err;
@@ -122,7 +135,9 @@ static int do_changename(const char *dev
 		return -1;
 	err = ioctl(fd, SIOCSIFNAME, &ifr);
 	if (err) {
+#ifdef NO_OPTSIZE
 		perror("SIOCSIFNAME");
+#endif
 		close(fd);
 		return -1;
 	}
@@ -143,7 +158,9 @@ static int set_qlen(const char *dev, int
 	strncpy(ifr.ifr_name, dev, IFNAMSIZ);
 	ifr.ifr_qlen = qlen;
 	if (ioctl(s, SIOCSIFTXQLEN, &ifr) < 0) {
+#ifdef NO_OPTSIZE
 		perror("SIOCSIFXQLEN");
+#endif
 		close(s);
 		return -1;
 	}
@@ -165,7 +182,9 @@ static int set_mtu(const char *dev, int
 	strncpy(ifr.ifr_name, dev, IFNAMSIZ);
 	ifr.ifr_mtu = mtu;
 	if (ioctl(s, SIOCSIFMTU, &ifr) < 0) {
+#ifdef NO_OPTSIZE
 		perror("SIOCSIFMTU");
+#endif
 		close(s);
 		return -1;
 	}
@@ -183,14 +202,18 @@ static int get_address(const char *dev,
 
 	s = socket(PF_PACKET, SOCK_DGRAM, 0);
 	if (s < 0) {
+#ifdef NO_OPTSIZE
 		perror("socket(PF_PACKET)");
+#endif
 		return -1;
 	}
 
 	memset(&ifr, 0, sizeof(ifr));
 	strncpy(ifr.ifr_name, dev, IFNAMSIZ);
 	if (ioctl(s, SIOCGIFINDEX, &ifr) < 0) {
+#ifdef NO_OPTSIZE
 		perror("SIOCGIFINDEX");
+#endif
 		close(s);
 		return -1;
 	}
@@ -200,14 +223,18 @@ static int get_address(const char *dev,
 	me.sll_ifindex = ifr.ifr_ifindex;
 	me.sll_protocol = htons(ETH_P_LOOP);
 	if (bind(s, (struct sockaddr*)&me, sizeof(me)) == -1) {
+#ifdef NO_OPTSIZE
 		perror("bind");
+#endif
 		close(s);
 		return -1;
 	}
 
 	alen = sizeof(me);
 	if (getsockname(s, (struct sockaddr*)&me, &alen) == -1) {
+#ifdef NO_OPTSIZE
 		perror("getsockname");
+#endif
 		close(s);
 		return -1;
 	}
@@ -228,7 +255,9 @@ static int parse_address(const char *dev
 	if (alen < 0)
 		return -1;
 	if (alen != halen) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Wrong address (%s) length: expected %d bytes\n", lla, halen);
+#endif
 		return -1;
 	}
 	return 0;
@@ -242,7 +271,9 @@ static int set_address(struct ifreq *ifr
 	if (s < 0)
 		return -1;
 	if (ioctl(s, brd?SIOCSIFHWBROADCAST:SIOCSIFHWADDR, ifr) < 0) {
+#ifdef NO_OPTSIZE
 		perror(brd?"SIOCSIFHWBROADCAST":"SIOCSIFHWADDR");
+#endif
 		close(s);
 		return -1;
 	}
@@ -365,7 +396,9 @@ static int do_set(int argc, char **argv)
 	}
 
 	if (!dev) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not enough of information: \"dev\" argument is required.\n");
+#endif
 		exit(-1);
 	}
 
@@ -420,11 +453,15 @@ int do_iplink(int argc, char **argv)
 		    matches(*argv, "lst") == 0 ||
 		    matches(*argv, "list") == 0)
 			return ipaddr_list_link(argc-1, argv+1);
+#ifdef NO_OPTSIZE
 		if (matches(*argv, "help") == 0)
 			usage();
+#endif
 	} else
 		return ipaddr_list_link(0, NULL);
+#ifdef NO_OPTSIZE
 
 	fprintf(stderr, "Command \"%s\" is unknown, try \"ip link help\".\n", *argv);
+#endif
 	exit(-1);
 }
--- iproute2/ip/ipmaddr.c
+++ iproute2/ip/ipmaddr.c
@@ -34,6 +34,7 @@ static struct {
 	int  family;
 } filter;
 
+#ifdef NO_OPTSIZE
 static void usage(void) __attribute__((noreturn));
 
 static void usage(void)
@@ -42,6 +43,9 @@ static void usage(void)
 	fprintf(stderr, "       ip maddr show [ dev STRING ]\n");
 	exit(-1);
 }
+#else
+#define usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 static int parse_hex(char *str, unsigned char *addr)
 {
@@ -300,24 +304,32 @@ int multiaddr_modify(int cmd, int argc,
 				duparg("address", *argv);
 			if (ll_addr_a2n(ifr.ifr_hwaddr.sa_data,
 					14, *argv) < 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Error: \"%s\" is not a legal ll address.\n", *argv);
+#endif
 				exit(1);
 			}
 		}
 		argc--; argv++;
 	}
 	if (ifr.ifr_name[0] == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not enough information: \"dev\" is required.\n");
+#endif
 		exit(-1);
 	}
 
 	fd = socket(AF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot create socket");
+#endif
 		exit(1);
 	}
 	if (ioctl(fd, cmd, (char*)&ifr) != 0) {
+#ifdef NO_OPTSIZE
 		perror("ioctl");
+#endif
 		exit(1);
 	}
 	close(fd);
@@ -337,8 +349,10 @@ int do_multiaddr(int argc, char **argv)
 	if (matches(*argv, "list") == 0 || matches(*argv, "show") == 0
 	    || matches(*argv, "lst") == 0)
 		return multiaddr_list(argc-1, argv+1);
+#ifdef NO_OPTSIZE
 	if (matches(*argv, "help") == 0)
 		usage();
 	fprintf(stderr, "Command \"%s\" is unknown, try \"ip maddr help\".\n", *argv);
+#endif
 	exit(-1);
 }
--- iproute2/ip/ipmroute.c
+++ iproute2/ip/ipmroute.c
@@ -31,6 +31,9 @@
 char filter_dev[16];
 int  filter_family;
 
+static char *viftable[32];
+#ifdef NO_OPTSIZE
+
 static void usage(void) __attribute__((noreturn));
 
 static void usage(void)
@@ -41,8 +44,9 @@ static void usage(void)
 #endif
 	exit(-1);
 }
-
-static char *viftable[32];
+#else
+#define usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 struct rtfilter
 {
@@ -198,8 +202,10 @@ int do_multiroute(int argc, char **argv)
 	if (matches(*argv, "list") == 0 || matches(*argv, "show") == 0
 	    || matches(*argv, "lst") == 0)
 		return mroute_list(argc-1, argv+1);
+#ifdef NO_OPTSIZE
 	if (matches(*argv, "help") == 0)
 		usage();
 	fprintf(stderr, "Command \"%s\" is unknown, try \"ip mroute help\".\n", *argv);
+#endif
 	exit(-1);
 }
--- iproute2/ip/ipneigh.c
+++ iproute2/ip/ipneigh.c
@@ -45,6 +45,7 @@ static struct
 	int flushe;
 } filter;
 
+#ifdef NO_OPTSIZE
 static void usage(void) __attribute__((noreturn));
 
 static void usage(void)
@@ -55,6 +56,9 @@ static void usage(void)
 	fprintf(stderr, "       ip neigh {show|flush} [ to PREFIX ] [ dev DEV ] [ nud STATE ]\n");
 	exit(-1);
 }
+#else
+#define usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 int nud_state_a2n(unsigned *state, char *arg)
 {
@@ -88,7 +92,9 @@ int nud_state_a2n(unsigned *state, char
 static int flush_update(void)
 {
 	if (rtnl_send(&rth, filter.flushb, filter.flushp) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Failed to send flush request\n");
+#endif
 		return -1;
 	}
 	filter.flushp = 0;
@@ -157,7 +163,9 @@ static int ipneigh_modify(int cmd, int f
 		argc--; argv++;
 	}
 	if (d == NULL || !dst_ok || dst.family == AF_UNSPEC) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Device and destination are required arguments.\n");
+#endif
 		exit(-1);
 	}
 	req.ndm.ndm_family = dst.family;
@@ -174,7 +182,9 @@ static int ipneigh_modify(int cmd, int f
 	ll_init_map(&rth);
 
 	if ((req.ndm.ndm_ifindex = ll_name_to_index(d)) == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Cannot find device \"%s\"\n", d);
+#endif
 		return -1;
 	}
 
@@ -194,14 +204,18 @@ int print_neigh(const struct sockaddr_nl
 	char abuf[256];
 
 	if (n->nlmsg_type != RTM_NEWNEIGH && n->nlmsg_type != RTM_DELNEIGH) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not RTM_NEWNEIGH: %08x %08x %08x\n",
 			n->nlmsg_len, n->nlmsg_type, n->nlmsg_flags);
+#endif
 
 		return 0;
 	}
 	len -= NLMSG_LENGTH(sizeof(*r));
 	if (len < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "BUG: wrong nlmsg len %d\n", len);
+#endif
 		return -1;
 	}
 
@@ -329,7 +343,9 @@ int do_show_or_flush(int argc, char **ar
 
 	if (flush) {
 		if (argc <= 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Flush requires arguments.\n");
+#endif
 			return -1;
 		}
 		filter.state = ~(NUD_PERMANENT|NUD_NOARP);
@@ -378,7 +394,9 @@ int do_show_or_flush(int argc, char **ar
 
 	if (filter_dev) {
 		if ((filter.index = ll_name_to_index(filter_dev)) == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Cannot find device \"%s\"\n", filter_dev);
+#endif
 			return -1;
 		}
 	}
@@ -394,17 +412,23 @@ int do_show_or_flush(int argc, char **ar
 
 		while (round < MAX_ROUNDS) {
 			if (rtnl_wilddump_request(&rth, filter.family, RTM_GETNEIGH) < 0) {
+#ifdef NO_OPTSIZE
 				perror("Cannot send dump request");
+#endif
 				exit(1);
 			}
 			filter.flushed = 0;
 			if (rtnl_dump_filter(&rth, print_neigh, stdout, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Flush terminated\n");
+#endif
 				exit(1);
 			}
 			if (filter.flushed == 0) {
 				if (round == 0) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "Nothing to flush.\n");
+#endif
 				} else if (show_stats)
 					printf("*** Flush is complete after %d round%s ***\n", round, round>1?"s":"");
 				fflush(stdout);
@@ -424,12 +448,16 @@ int do_show_or_flush(int argc, char **ar
 	}
 
 	if (rtnl_wilddump_request(&rth, filter.family, RTM_GETNEIGH) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot send dump request");
+#endif
 		exit(1);
 	}
 
 	if (rtnl_dump_filter(&rth, print_neigh, stdout, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Dump terminated\n");
+#endif
 		exit(1);
 	}
 
@@ -449,7 +477,9 @@ int do_ipneigh(int argc, char **argv)
 		if (matches(*argv, "delete") == 0)
 			return ipneigh_modify(RTM_DELNEIGH, 0, argc-1, argv+1);
 		if (matches(*argv, "get") == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Sorry, \"neigh get\" is not implemented :-(\n");
+#endif
 			return -1;
 		}
 		if (matches(*argv, "show") == 0 ||
@@ -458,11 +488,15 @@ int do_ipneigh(int argc, char **argv)
 			return do_show_or_flush(argc-1, argv+1, 0);
 		if (matches(*argv, "flush") == 0)
 			return do_show_or_flush(argc-1, argv+1, 1);
+#ifdef NO_OPTSIZE
 		if (matches(*argv, "help") == 0)
 			usage();
+#endif
 	} else
 		return do_show_or_flush(0, NULL, 0);
 
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Command \"%s\" is unknown, try \"ip neigh help\".\n", *argv);
+#endif
 	exit(-1);
 }
--- iproute2/ip/ipntable.c
+++ iproute2/ip/ipntable.c
@@ -40,6 +40,7 @@ static struct
 	char name[1024];
 } filter;
 
+#ifdef NO_OPTSIZE
 static void usage(void) __attribute__((noreturn));
 
 static void usage(void)
@@ -59,6 +60,9 @@ static void usage(void)
 
 	exit(-1);
 }
+#else
+#define usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 static int ipntable_modify(int cmd, int flags, int argc, char **argv)
 {
@@ -147,7 +151,9 @@ static int ipntable_modify(int cmd, int
 			NEXT_ARG();
 			ifindex = ll_name_to_index(*argv);
 			if (ifindex == 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Cannot find device \"%s\"\n", *argv);
+#endif
 				return -1;
 			}
 
@@ -304,7 +310,9 @@ static int ipntable_modify(int cmd, int
 	if (!namep)
 		missarg("NAME");
 	if (!threshsp && !gc_intp && !parms_change) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not enough information: changable attributes required.\n");
+#endif
 		exit(-1);
 	}
 
@@ -332,7 +340,9 @@ static const char *ntable_strtime_delta(
 	memset(&now, 0, sizeof(now));
 
 	if (gettimeofday(&now, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		perror("gettimeofday");
+#endif
 		goto error;
 	}
 
@@ -359,13 +369,17 @@ int print_ntable(const struct sockaddr_n
 	int ret;
 
 	if (n->nlmsg_type != RTM_NEWNEIGHTBL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not NEIGHTBL: %08x %08x %08x\n",
 			n->nlmsg_len, n->nlmsg_type, n->nlmsg_flags);
+#endif
 		return 0;
 	}
 	len -= NLMSG_LENGTH(sizeof(*ndtm));
 	if (len < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "BUG: wrong nlmsg len %d\n", len);
+#endif
 		return -1;
 	}
 
@@ -621,12 +635,16 @@ static int ipntable_show(int argc, char
 	}
 
 	if (rtnl_wilddump_request(&rth, preferred_family, RTM_GETNEIGHTBL) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot send dump request");
+#endif
 		exit(1);
 	}
 
 	if (rtnl_dump_filter(&rth, print_ntable, stdout, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Dump terminated\n");
+#endif
 		exit(1);
 	}
 
@@ -647,11 +665,15 @@ int do_ipntable(int argc, char **argv)
 		    matches(*argv, "lst") == 0 ||
 		    matches(*argv, "list") == 0)
 			return ipntable_show(argc-1, argv+1);
+#ifdef NO_OPTSIZE
 		if (matches(*argv, "help") == 0)
 			usage();
+#endif
 	} else
 		return ipntable_show(0, NULL);
 
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Command \"%s\" is unknown, try \"ip ntable help\".\n", *argv);
+#endif
 	exit(-1);
 }
--- iproute2/ip/ipprefix.c
+++ iproute2/ip/ipprefix.c
@@ -42,14 +42,18 @@ int print_prefix(const struct sockaddr_n
 	int family = preferred_family;
 
 	if (n->nlmsg_type != RTM_NEWPREFIX) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not a prefix: %08x %08x %08x\n",
 			n->nlmsg_len, n->nlmsg_type, n->nlmsg_flags);
+#endif
 		return 0;
 	}
 
 	len -= NLMSG_LENGTH(sizeof(*prefix));
 	if (len < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "BUG: wrong nlmsg len %d\n", len);
+#endif
 		return -1;
 	}
 
@@ -59,11 +63,15 @@ int print_prefix(const struct sockaddr_n
 		return 0;
 
 	if (prefix->prefix_family != AF_INET6) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "wrong family %d\n", prefix->prefix_family);
+#endif
 		return 0;
 	}
 	if (prefix->prefix_type != ND_OPT_PREFIX_INFORMATION) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "wrong ND type %d\n", prefix->prefix_type);
+#endif
 		return 0;
 	}
 
--- iproute2/ip/iproute.c
+++ iproute2/ip/iproute.c
@@ -52,6 +52,8 @@ static const char *mx_names[RTAX_MAX+1]
 	[RTAX_INITCWND] = "initcwnd",
 	[RTAX_FEATURES] = "features",
 };
+
+#ifdef NO_OPTSIZE
 static void usage(void) __attribute__((noreturn));
 
 static void usage(void)
@@ -84,7 +86,9 @@ static void usage(void)
 	fprintf(stderr, "RTPROTO := [ kernel | boot | static | NUMBER ]\n");
 	exit(-1);
 }
-
+#else
+#define usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 static struct
 {
@@ -120,7 +124,9 @@ static char *mp_alg_names[IP_MP_ALG_MAX+
 static int flush_update(void)
 {
 	if (rtnl_send(&rth, filter.flushb, filter.flushp) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Failed to send flush request\n");
+#endif
 		return -1;
 	}
 	filter.flushp = 0;
@@ -145,15 +151,19 @@ int print_route(const struct sockaddr_nl
 	static int hz;
 
 	if (n->nlmsg_type != RTM_NEWROUTE && n->nlmsg_type != RTM_DELROUTE) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not a route: %08x %08x %08x\n",
 			n->nlmsg_len, n->nlmsg_type, n->nlmsg_flags);
+#endif
 		return 0;
 	}
 	if (filter.flushb && n->nlmsg_type != RTM_NEWROUTE)
 		return 0;
 	len -= NLMSG_LENGTH(sizeof(*r));
 	if (len < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "BUG: wrong nlmsg len %d\n", len);
+#endif
 		return -1;
 	}
 
@@ -613,7 +623,9 @@ int parse_one_nh(struct rtattr *rta, str
 		} else if (strcmp(*argv, "dev") == 0) {
 			NEXT_ARG();
 			if ((rtnh->rtnh_ifindex = ll_name_to_index(*argv)) == 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Cannot find device \"%s\"\n", *argv);
+#endif
 				exit(1);
 			}
 		} else if (strcmp(*argv, "weight") == 0) {
@@ -651,11 +663,15 @@ int parse_nexthops(struct nlmsghdr *n, s
 
 	while (argc > 0) {
 		if (strcmp(*argv, "nexthop") != 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Error: \"nexthop\" or end of line is expected instead of \"%s\"\n", *argv);
+#endif
 			exit(-1);
 		}
 		if (argc <= 1) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Error: unexpected end of line after \"nexthop\"\n");
+#endif
 			exit(-1);
 		}
 		memset(rtnh, 0, sizeof(*rtnh));
@@ -934,7 +950,9 @@ int iproute_modify(int cmd, unsigned fla
 
 		if (d) {
 			if ((idx = ll_name_to_index(d)) == 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Cannot find device \"%s\"\n", d);
+#endif
 				return -1;
 			}
 			addattr32(&req.n, sizeof(req), RTA_OIF, idx);
@@ -1015,14 +1033,18 @@ static int iproute_flush_cache(void)
 	char *buffer = "-1";
 
 	if (flush_fd < 0) {
+#ifdef NO_OPTSIZE
 		fprintf (stderr, "Cannot open \"%s\"\n", ROUTE_FLUSH_PATH);
+#endif
 		return -1;
 	}
 
 	len = strlen (buffer);
 
 	if ((write (flush_fd, (void *)buffer, len)) < len) {
+#ifdef NO_OPTSIZE
 		fprintf (stderr, "Cannot flush routing cache\n");
+#endif
 		return -1;
 	}
 	close(flush_fd);
@@ -1040,7 +1062,9 @@ static int iproute_list_or_flush(int arg
 	filter.tb = RT_TABLE_MAIN;
 
 	if (flush && argc <= 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "\"ip route flush\" requires arguments.\n");
+#endif
 		return -1;
 	}
 
@@ -1173,7 +1197,9 @@ static int iproute_list_or_flush(int arg
 
 		if (id) {
 			if ((idx = ll_name_to_index(id)) == 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Cannot find device \"%s\"\n", id);
+#endif
 				return -1;
 			}
 			filter.iif = idx;
@@ -1181,7 +1207,9 @@ static int iproute_list_or_flush(int arg
 		}
 		if (od) {
 			if ((idx = ll_name_to_index(od)) == 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Cannot find device \"%s\"\n", od);
+#endif
 				return -1;
 			}
 			filter.oif = idx;
@@ -1210,18 +1238,24 @@ static int iproute_list_or_flush(int arg
 
 		for (;;) {
 			if (rtnl_wilddump_request(&rth, do_ipv6, RTM_GETROUTE) < 0) {
+#ifdef NO_OPTSIZE
 				perror("Cannot send dump request");
+#endif
 				exit(1);
 			}
 			filter.flushed = 0;
 			if (rtnl_dump_filter(&rth, print_route, stdout, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Flush terminated\n");
+#endif
 				exit(1);
 			}
 			if (filter.flushed == 0) {
 				if (round == 0) {
+#ifdef NO_OPTSIZE
 					if (!filter.cloned || do_ipv6 == AF_INET6)
 						fprintf(stderr, "Nothing to flush.\n");
+#endif
 				} else if (show_stats)
 					printf("*** Flush is complete after %d round%s ***\n", round, round>1?"s":"");
 				fflush(stdout);
@@ -1246,18 +1280,24 @@ static int iproute_list_or_flush(int arg
 
 	if (!filter.cloned) {
 		if (rtnl_wilddump_request(&rth, do_ipv6, RTM_GETROUTE) < 0) {
+#ifdef NO_OPTSIZE
 			perror("Cannot send dump request");
+#endif
 			exit(1);
 		}
 	} else {
 		if (rtnl_rtcache_request(&rth, do_ipv6) < 0) {
+#ifdef NO_OPTSIZE
 			perror("Cannot send dump request");
+#endif
 			exit(1);
 		}
 	}
 
 	if (rtnl_dump_filter(&rth, print_route, stdout, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Dump terminated\n");
+#endif
 		exit(1);
 	}
 
@@ -1342,7 +1382,9 @@ int iproute_get(int argc, char **argv)
 	}
 
 	if (req.r.rtm_dst_len == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "need at least destination address\n");
+#endif
 		exit(1);
 	}
 
@@ -1353,14 +1395,18 @@ int iproute_get(int argc, char **argv)
 
 		if (idev) {
 			if ((idx = ll_name_to_index(idev)) == 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Cannot find device \"%s\"\n", idev);
+#endif
 				return -1;
 			}
 			addattr32(&req.n, sizeof(req), RTA_IIF, idx);
 		}
 		if (odev) {
 			if ((idx = ll_name_to_index(odev)) == 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Cannot find device \"%s\"\n", odev);
+#endif
 				return -1;
 			}
 			addattr32(&req.n, sizeof(req), RTA_OIF, idx);
@@ -1379,17 +1425,23 @@ int iproute_get(int argc, char **argv)
 		struct rtattr * tb[RTA_MAX+1];
 
 		if (print_route(NULL, &req.n, (void*)stdout) < 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "An error :-)\n");
+#endif
 			exit(1);
 		}
 
 		if (req.n.nlmsg_type != RTM_NEWROUTE) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Not a route?\n");
+#endif
 			return -1;
 		}
 		len -= NLMSG_LENGTH(sizeof(*r));
 		if (len < 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Wrong len %d\n", len);
+#endif
 			return -1;
 		}
 
@@ -1399,7 +1451,9 @@ int iproute_get(int argc, char **argv)
 			tb[RTA_PREFSRC]->rta_type = RTA_SRC;
 			r->rtm_src_len = 8*RTA_PAYLOAD(tb[RTA_PREFSRC]);
 		} else if (!tb[RTA_SRC]) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Failed to connect the route\n");
+#endif
 			return -1;
 		}
 		if (!odev && tb[RTA_OIF])
@@ -1416,7 +1470,9 @@ int iproute_get(int argc, char **argv)
 	}
 
 	if (print_route(NULL, &req.n, (void*)stdout) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "An error :-)\n");
+#endif
 		exit(1);
 	}
 
@@ -1463,9 +1519,11 @@ int do_iproute(int argc, char **argv)
 		return iproute_get(argc-1, argv+1);
 	if (matches(*argv, "flush") == 0)
 		return iproute_list_or_flush(argc-1, argv+1, 1);
+#ifdef NO_OPTSIZE
 	if (matches(*argv, "help") == 0)
 		usage();
 	fprintf(stderr, "Command \"%s\" is unknown, try \"ip route help\".\n", *argv);
+#endif
 	exit(-1);
 }
 
--- iproute2/ip/iprule.c
+++ iproute2/ip/iprule.c
@@ -32,6 +32,7 @@
 
 extern struct rtnl_handle rth;
 
+#ifdef NO_OPTSIZE
 static void usage(void) __attribute__((noreturn));
 
 static void usage(void)
@@ -46,6 +47,9 @@ static void usage(void)
 	fprintf(stderr, "TABLE_ID := [ local | main | default | NUMBER ]\n");
 	exit(-1);
 }
+#else
+#define usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 int print_rule(const struct sockaddr_nl *who, struct nlmsghdr *n, void *arg)
 {
@@ -200,17 +204,23 @@ static int iprule_list(int argc, char **
 		af = AF_INET;
 
 	if (argc > 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "\"ip rule show\" does not take any arguments.\n");
+#endif
 		return -1;
 	}
 
 	if (rtnl_wilddump_request(&rth, af, RTM_GETRULE) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot send dump request");
+#endif
 		return 1;
 	}
 
 	if (rtnl_dump_filter(&rth, print_rule, stdout, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Dump terminated\n");
+#endif
 		return 1;
 	}
 
@@ -313,7 +323,9 @@ static int iprule_modify(int cmd, int ar
 		} else if (strcmp(*argv, "nat") == 0 ||
 			   matches(*argv, "map-to") == 0) {
 			NEXT_ARG();
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Warning: route NAT is deprecated\n");
+#endif
 			addattr32(&req.n, sizeof(req), RTA_GATEWAY, get_addr32(*argv));
 			req.r.rtm_type = RTN_NAT;
 		} else {
@@ -392,17 +404,23 @@ static int iprule_flush(int argc, char *
 		af = AF_INET;
 
 	if (argc > 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "\"ip rule flush\" does not allow arguments\n");
+#endif
 		return -1;
 	}
 
 	if (rtnl_wilddump_request(&rth, af, RTM_GETRULE) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot send dump request");
+#endif
 		return 1;
 	}
 
 	if (rtnl_dump_filter(&rth, flush_rule, NULL, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Flush terminated\n");
+#endif
 		return 1;
 	}
 
@@ -423,10 +441,13 @@ int do_iprule(int argc, char **argv)
 		return iprule_modify(RTM_DELRULE, argc-1, argv+1);
 	} else if (matches(argv[0], "flush") == 0) {
 		return iprule_flush(argc-1, argv+1);
-	} else if (matches(argv[0], "help") == 0)
+	}
+#ifdef NO_OPTSIZE
+	else if (matches(argv[0], "help") == 0)
 		usage();
 
 	fprintf(stderr, "Command \"%s\" is unknown, try \"ip rule help\".\n", *argv);
+#endif
 	exit(-1);
 }
 
--- iproute2/ip/iptunnel.c
+++ iproute2/ip/iptunnel.c
@@ -34,6 +34,7 @@
 #include "ip_common.h"
 #include "tunnel.h"
 
+#ifdef NO_OPTSIZE
 static void usage(void) __attribute__((noreturn));
 
 static void usage(void)
@@ -50,6 +51,9 @@ static void usage(void)
 	fprintf(stderr, "       KEY  := { DOTTED_QUAD | NUMBER }\n");
 	exit(-1);
 }
+#else
+#define usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 static int parse_args(int argc, char **argv, int cmd, struct ip_tunnel_parm *p)
 {
@@ -72,26 +76,34 @@ static int parse_args(int argc, char **a
 			if (strcmp(*argv, "ipip") == 0 ||
 			    strcmp(*argv, "ip/ip") == 0) {
 				if (p->iph.protocol && p->iph.protocol != IPPROTO_IPIP) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr,"You managed to ask for more than one tunnel mode.\n");
+#endif
 					exit(-1);
 				}
 				p->iph.protocol = IPPROTO_IPIP;
 			} else if (strcmp(*argv, "gre") == 0 ||
 				   strcmp(*argv, "gre/ip") == 0) {
 				if (p->iph.protocol && p->iph.protocol != IPPROTO_GRE) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr,"You managed to ask for more than one tunnel mode.\n");
+#endif
 					exit(-1);
 				}
 				p->iph.protocol = IPPROTO_GRE;
 			} else if (strcmp(*argv, "sit") == 0 ||
 				   strcmp(*argv, "ipv6/ip") == 0) {
 				if (p->iph.protocol && p->iph.protocol != IPPROTO_IPV6) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr,"You managed to ask for more than one tunnel mode.\n");
+#endif
 					exit(-1);
 				}
 				p->iph.protocol = IPPROTO_IPV6;
 			} else {
+#ifdef NO_OPTSIZE
 				fprintf(stderr,"Cannot guess tunnel mode.\n");
+#endif
 				exit(-1);
 			}
 		} else if (strcmp(*argv, "key") == 0) {
@@ -103,7 +115,9 @@ static int parse_args(int argc, char **a
 				p->i_key = p->o_key = get_addr32(*argv);
 			else {
 				if (get_unsigned(&uval, *argv, 0)<0) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "invalid value of \"key\"\n");
+#endif
 					exit(-1);
 				}
 				p->i_key = p->o_key = htonl(uval);
@@ -116,7 +130,9 @@ static int parse_args(int argc, char **a
 				p->o_key = get_addr32(*argv);
 			else {
 				if (get_unsigned(&uval, *argv, 0)<0) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "invalid value of \"ikey\"\n");
+#endif
 					exit(-1);
 				}
 				p->i_key = htonl(uval);
@@ -129,7 +145,9 @@ static int parse_args(int argc, char **a
 				p->o_key = get_addr32(*argv);
 			else {
 				if (get_unsigned(&uval, *argv, 0)<0) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "invalid value of \"okey\"\n");
+#endif
 					exit(-1);
 				}
 				p->o_key = htonl(uval);
@@ -216,7 +234,9 @@ static int parse_args(int argc, char **a
 
 	if (p->iph.protocol == IPPROTO_IPIP || p->iph.protocol == IPPROTO_IPV6) {
 		if ((p->i_flags & GRE_KEY) || (p->o_flags & GRE_KEY)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Keys are not allowed with ipip and sit.\n");
+#endif
 			return -1;
 		}
 	}
@@ -236,7 +256,9 @@ static int parse_args(int argc, char **a
 		p->o_flags |= GRE_KEY;
 	}
 	if (IN_MULTICAST(ntohl(p->iph.daddr)) && !p->iph.saddr) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Broadcast tunnel requires a source address.\n");
+#endif
 		return -1;
 	}
 	return 0;
@@ -251,7 +273,9 @@ static int do_add(int cmd, int argc, cha
 		return -1;
 
 	if (p.iph.ttl && p.iph.frag_off == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "ttl != 0 and noptmudisc are incompatible\n");
+#endif
 		return -1;
 	}
 
@@ -263,7 +287,9 @@ static int do_add(int cmd, int argc, cha
 	case IPPROTO_IPV6:
 		return tnl_add_ioctl(cmd, "sit0", p.name, &p);
 	default:
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "cannot determine tunnel mode (ipip, gre or sit)\n");
+#endif
 		return -1;
 	}
 	return -1;
@@ -364,7 +390,9 @@ static int do_tunnels_list(struct ip_tun
 	char buf[512];
 	FILE *fp = fopen("/proc/net/dev", "r");
 	if (fp == NULL) {
+#ifdef NO_OPTSIZE
 		perror("fopen");
+#endif
 		return -1;
 	}
 
@@ -376,7 +404,9 @@ static int do_tunnels_list(struct ip_tun
 		buf[sizeof(buf) - 1] = 0;
 		if ((ptr = strchr(buf, ':')) == NULL ||
 		    (*ptr++ = 0, sscanf(buf, "%s", name) != 1)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Wrong format of /proc/net/dev. Sorry.\n");
+#endif
 			return -1;
 		}
 		if (sscanf(ptr, "%ld%ld%ld%ld%ld%ld%ld%*d%ld%ld%ld%ld%ld%ld%ld",
@@ -389,7 +419,9 @@ static int do_tunnels_list(struct ip_tun
 			continue;
 		type = tnl_ioctl_get_iftype(name);
 		if (type == -1) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Failed to get type of [%s]\n", name);
+#endif
 			continue;
 		}
 		if (type != ARPHRD_TUNNEL && type != ARPHRD_IPGRE && type != ARPHRD_SIT)
@@ -464,7 +496,9 @@ int do_iptunnel(int argc, char **argv)
 	case AF_INET6:
 		return do_ip6tunnel(argc, argv);
 	default:
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Unsupported family:%d\n", preferred_family);
+#endif
 		exit(-1);
 	}
 
@@ -479,11 +513,16 @@ int do_iptunnel(int argc, char **argv)
 		    matches(*argv, "lst") == 0 ||
 		    matches(*argv, "list") == 0)
 			return do_show(argc-1, argv+1);
+#ifdef NO_OPTSIZE
 		if (matches(*argv, "help") == 0)
 			usage();
-	} else
+#endif
+	}
+#ifdef NO_OPTSIZE
+	else
 		return do_show(0, NULL);
 
 	fprintf(stderr, "Command \"%s\" is unknown, try \"ip tunnel help\".\n", *argv);
+#endif
 	exit(-1);
 }
--- iproute2/ip/Makefile
+++ iproute2/ip/Makefile
@@ -1,10 +1,15 @@
 IPOBJ=ip.o ipaddress.o iproute.o iprule.o \
     rtm_map.o iptunnel.o ip6tunnel.o tunnel.o ipneigh.o ipntable.o iplink.o \
-    ipmaddr.o ipmonitor.o ipmroute.o ipprefix.o \
-    ipxfrm.o xfrm_state.o xfrm_policy.o xfrm_monitor.o
+    ipmaddr.o ipmroute.o ipprefix.o \
+
+ifdef OPTSIZE_FLAG
+IPOBJ+=ipmonitor.o xfrm_monitor.o ipxfrm.o xfrm_state.o xfrm_policy.o
+endif
 
 RTMONOBJ=rtmon.o
 
+LDFLAGS= -ffunction-sections -fdata-sections -Wl,--gc-sections
+
 ALLOBJ=$(IPOBJ) $(RTMONOBJ)
 SCRIPTS=ifcfg rtpr routel routef
 TARGETS=ip rtmon
--- iproute2/ip/rtmon.c
+++ iproute2/ip/rtmon.c
@@ -56,12 +56,16 @@ static int dump_msg(const struct sockadd
 	return 0;
 }
 
+#ifdef NO_OPTSIZE
 void usage(void)
 {
 	fprintf(stderr, "Usage: rtmon file FILE [ all | LISTofOBJECTS]\n");
 	fprintf(stderr, "LISTofOBJECTS := [ link ] [ address ] [ route ]\n");
 	exit(-1);
 }
+#else
+#define usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 int
 main(int argc, char **argv)
@@ -90,7 +94,9 @@ main(int argc, char **argv)
 			else if (strcmp(argv[1], "help") == 0)
 				usage();
 			else {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Protocol ID \"%s\" is unknown, try \"rtmon help\".\n", argv[1]);
+#endif
 				exit(-1);
 			}
 		} else if (strcmp(argv[1], "-4") == 0) {
@@ -122,14 +128,18 @@ main(int argc, char **argv)
 		} else if (matches(argv[1], "help") == 0) {
 			usage();
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Argument \"%s\" is unknown, try \"rtmon help\".\n", argv[1]);
+#endif
 			exit(-1);
 		}
 		argc--;	argv++;
 	}
 
 	if (file == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not enough information: argument \"file\" is required\n");
+#endif
 		exit(-1);
 	}
 	if (llink)
@@ -149,7 +159,9 @@ main(int argc, char **argv)
 
 	fp = fopen(file, "w");
 	if (fp == NULL) {
+#ifdef NO_OPTSIZE
 		perror("Cannot fopen");
+#endif
 		exit(-1);
 	}
 
@@ -157,14 +169,18 @@ main(int argc, char **argv)
 		exit(1);
 
 	if (rtnl_wilddump_request(&rth, AF_UNSPEC, RTM_GETLINK) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot send dump request");
+#endif
 		exit(1);
 	}
 
 	write_stamp(fp);
 
 	if (rtnl_dump_filter(&rth, dump_msg, fp, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Dump terminated\n");
+#endif
 		return 1;
 	}
 
--- iproute2/ip/tunnel.c
+++ iproute2/ip/tunnel.c
@@ -69,7 +69,9 @@ int tnl_ioctl_get_ifindex(const char *de
 	fd = socket(preferred_family, SOCK_DGRAM, 0);
 	err = ioctl(fd, SIOCGIFINDEX, &ifr);
 	if (err) {
+#ifdef NO_OPTSIZE
 		perror("ioctl");
+#endif
 		return 0;
 	}
 	close(fd);
@@ -86,7 +88,9 @@ int tnl_ioctl_get_iftype(const char *dev
 	fd = socket(preferred_family, SOCK_DGRAM, 0);
 	err = ioctl(fd, SIOCGIFHWADDR, &ifr);
 	if (err) {
+#ifdef NO_OPTSIZE
 		perror("ioctl");
+#endif
 		return -1;
 	}
 	close(fd);
@@ -104,7 +108,9 @@ char * tnl_ioctl_get_ifname(int idx)
 	fd = socket(preferred_family, SOCK_DGRAM, 0);
 	err = ioctl(fd, SIOCGIFNAME, &ifr);
 	if (err) {
+#ifdef NO_OPTSIZE
 		perror("ioctl");
+#endif
 		return NULL;
 	}
 	close(fd);
@@ -122,7 +128,9 @@ int tnl_get_ioctl(const char *basedev, v
 	fd = socket(preferred_family, SOCK_DGRAM, 0);
 	err = ioctl(fd, SIOCGETTUNNEL, &ifr);
 	if (err)
+#ifdef NO_OPTSIZE
 		perror("ioctl");
+#endif
 	close(fd);
 	return err;
 }
@@ -140,8 +148,10 @@ int tnl_add_ioctl(int cmd, const char *b
 	ifr.ifr_ifru.ifru_data = p;
 	fd = socket(preferred_family, SOCK_DGRAM, 0);
 	err = ioctl(fd, cmd, &ifr);
+#ifdef NO_OPTSIZE
 	if (err)
 		perror("ioctl");
+#endif
 	close(fd);
 	return err;
 }
@@ -159,8 +169,10 @@ int tnl_del_ioctl(const char *basedev, c
 	ifr.ifr_ifru.ifru_data = p;
 	fd = socket(preferred_family, SOCK_DGRAM, 0);
 	err = ioctl(fd, SIOCDELTUNNEL, &ifr);
+#ifdef NO_OPTSIZE
 	if (err)
 		perror("ioctl");
+#endif
 	close(fd);
 	return err;
 }
--- iproute2/lib/libnetlink.c
+++ iproute2/lib/libnetlink.c
@@ -44,17 +44,23 @@ int rtnl_open_byproto(struct rtnl_handle
 
 	rth->fd = socket(AF_NETLINK, SOCK_RAW, protocol);
 	if (rth->fd < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot open netlink socket");
+#endif
 		return -1;
 	}
 
 	if (setsockopt(rth->fd,SOL_SOCKET,SO_SNDBUF,&sndbuf,sizeof(sndbuf)) < 0) {
+#ifdef NO_OPTSIZE
 		perror("SO_SNDBUF");
+#endif
 		return -1;
 	}
 
 	if (setsockopt(rth->fd,SOL_SOCKET,SO_RCVBUF,&rcvbuf,sizeof(rcvbuf)) < 0) {
+#ifdef NO_OPTSIZE
 		perror("SO_RCVBUF");
+#endif
 		return -1;
 	}
 
@@ -63,20 +69,28 @@ int rtnl_open_byproto(struct rtnl_handle
 	rth->local.nl_groups = subscriptions;
 
 	if (bind(rth->fd, (struct sockaddr*)&rth->local, sizeof(rth->local)) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot bind netlink socket");
+#endif
 		return -1;
 	}
 	addr_len = sizeof(rth->local);
 	if (getsockname(rth->fd, (struct sockaddr*)&rth->local, &addr_len) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot getsockname");
+#endif
 		return -1;
 	}
 	if (addr_len != sizeof(rth->local)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Wrong address length %d\n", addr_len);
+#endif
 		return -1;
 	}
 	if (rth->local.nl_family != AF_NETLINK) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Wrong address family %d\n", rth->local.nl_family);
+#endif
 		return -1;
 	}
 	rth->seq = time(NULL);
@@ -175,12 +189,16 @@ int rtnl_dump_filter(struct rtnl_handle
 		if (status < 0) {
 			if (errno == EINTR)
 				continue;
+#ifdef NO_OPTSIZE
 			perror("OVERRUN");
+#endif
 			continue;
 		}
 
 		if (status == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "EOF on netlink\n");
+#endif
 			return -1;
 		}
 
@@ -204,10 +222,14 @@ int rtnl_dump_filter(struct rtnl_handle
 			if (h->nlmsg_type == NLMSG_ERROR) {
 				struct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);
 				if (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "ERROR truncated\n");
+#endif
 				} else {
 					errno = -err->error;
+#ifdef NO_OPTSIZE
 					perror("RTNETLINK answers");
+#endif
 				}
 				return -1;
 			}
@@ -219,11 +241,15 @@ skip_it:
 			h = NLMSG_NEXT(h, status);
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Message truncated\n");
+#endif
 			continue;
 		}
 		if (status) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "!!!Remnant of size %d\n", status);
+#endif
 			exit(1);
 		}
 	}
@@ -263,7 +289,9 @@ int rtnl_talk(struct rtnl_handle *rtnl,
 	status = sendmsg(rtnl->fd, &msg, 0);
 
 	if (status < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot talk to rtnetlink");
+#endif
 		return -1;
 	}
 
@@ -278,15 +306,21 @@ int rtnl_talk(struct rtnl_handle *rtnl,
 		if (status < 0) {
 			if (errno == EINTR)
 				continue;
+#ifdef NO_OPTSIZE
 			perror("OVERRUN");
+#endif
 			continue;
 		}
 		if (status == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "EOF on netlink\n");
+#endif
 			return -1;
 		}
 		if (msg.msg_namelen != sizeof(nladdr)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "sender address length == %d\n", msg.msg_namelen);
+#endif
 			exit(1);
 		}
 		for (h = (struct nlmsghdr*)buf; status >= sizeof(*h); ) {
@@ -296,10 +330,14 @@ int rtnl_talk(struct rtnl_handle *rtnl,
 
 			if (l<0 || len>status) {
 				if (msg.msg_flags & MSG_TRUNC) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "Truncated message\n");
+#endif
 					return -1;
 				}
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "!!!malformed message: len=%d\n", len);
+#endif
 				exit(1);
 			}
 
@@ -320,7 +358,9 @@ int rtnl_talk(struct rtnl_handle *rtnl,
 			if (h->nlmsg_type == NLMSG_ERROR) {
 				struct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);
 				if (l < sizeof(struct nlmsgerr)) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "ERROR truncated\n");
+#endif
 				} else {
 					errno = -err->error;
 					if (errno == 0) {
@@ -328,7 +368,9 @@ int rtnl_talk(struct rtnl_handle *rtnl,
 							memcpy(answer, h, h->nlmsg_len);
 						return 0;
 					}
+#ifdef NO_OPTSIZE
 					perror("RTNETLINK answers");
+#endif
 				}
 				return -1;
 			}
@@ -337,17 +379,23 @@ int rtnl_talk(struct rtnl_handle *rtnl,
 				return 0;
 			}
 
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Unexpected reply!!!\n");
+#endif
 
 			status -= NLMSG_ALIGN(len);
 			h = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Message truncated\n");
+#endif
 			continue;
 		}
 		if (status) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "!!!Remnant of size %d\n", status);
+#endif
 			exit(1);
 		}
 	}
@@ -382,15 +430,21 @@ int rtnl_listen(struct rtnl_handle *rtnl
 		if (status < 0) {
 			if (errno == EINTR)
 				continue;
+#ifdef NO_OPTSIZE
 			perror("OVERRUN");
+#endif
 			continue;
 		}
 		if (status == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "EOF on netlink\n");
+#endif
 			return -1;
 		}
 		if (msg.msg_namelen != sizeof(nladdr)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Sender address length == %d\n", msg.msg_namelen);
+#endif
 			exit(1);
 		}
 		for (h = (struct nlmsghdr*)buf; status >= sizeof(*h); ) {
@@ -400,10 +454,14 @@ int rtnl_listen(struct rtnl_handle *rtnl
 
 			if (l<0 || len>status) {
 				if (msg.msg_flags & MSG_TRUNC) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "Truncated message\n");
+#endif
 					return -1;
 				}
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "!!!malformed message: len=%d\n", len);
+#endif
 				exit(1);
 			}
 
@@ -415,11 +473,15 @@ int rtnl_listen(struct rtnl_handle *rtnl
 			h = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Message truncated\n");
+#endif
 			continue;
 		}
 		if (status) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "!!!Remnant of size %d\n", status);
+#endif
 			exit(1);
 		}
 	}
@@ -447,7 +509,9 @@ int rtnl_from_file(FILE *rtnl, rtnl_filt
 		if (status < 0) {
 			if (errno == EINTR)
 				continue;
+#ifdef NO_OPTSIZE
 			perror("rtnl_from_file: fread");
+#endif
 			return -1;
 		}
 		if (status == 0)
@@ -458,19 +522,25 @@ int rtnl_from_file(FILE *rtnl, rtnl_filt
 		l = len - sizeof(*h);
 
 		if (l<0 || len>sizeof(buf)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "!!!malformed message: len=%d @%lu\n",
 				len, ftell(rtnl));
+#endif
 			return -1;
 		}
 
 		status = fread(NLMSG_DATA(h), 1, NLMSG_ALIGN(l), rtnl);
 
 		if (status < 0) {
+#ifdef NO_OPTSIZE
 			perror("rtnl_from_file: fread");
+#endif
 			return -1;
 		}
 		if (status < l) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "rtnl-from_file: truncated message\n");
+#endif
 			return -1;
 		}
 
@@ -485,7 +555,9 @@ int addattr32(struct nlmsghdr *n, int ma
 	int len = RTA_LENGTH(4);
 	struct rtattr *rta;
 	if (NLMSG_ALIGN(n->nlmsg_len) + len > maxlen) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"addattr32: Error! max allowed bound %d exceeded\n",maxlen);
+#endif
 		return -1;
 	}
 	rta = NLMSG_TAIL(n);
@@ -503,7 +575,9 @@ int addattr_l(struct nlmsghdr *n, int ma
 	struct rtattr *rta;
 
 	if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "addattr_l ERROR: message exceeded bound of %d\n",maxlen);
+#endif
 		return -1;
 	}
 	rta = NLMSG_TAIL(n);
@@ -517,7 +591,9 @@ int addattr_l(struct nlmsghdr *n, int ma
 int addraw_l(struct nlmsghdr *n, int maxlen, const void *data, int len)
 {
 	if (NLMSG_ALIGN(n->nlmsg_len) + NLMSG_ALIGN(len) > maxlen) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "addraw_l ERROR: message exceeded bound of %d\n",maxlen);
+#endif
 		return -1;
 	}
 
@@ -533,7 +609,9 @@ int rta_addattr32(struct rtattr *rta, in
 	struct rtattr *subrta;
 
 	if (RTA_ALIGN(rta->rta_len) + len > maxlen) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"rta_addattr32: Error! max allowed bound %d exceeded\n",maxlen);
+#endif
 		return -1;
 	}
 	subrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));
@@ -551,7 +629,9 @@ int rta_addattr_l(struct rtattr *rta, in
 	int len = RTA_LENGTH(alen);
 
 	if (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len) > maxlen) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"rta_addattr_l: Error! max allowed bound %d exceeded\n",maxlen);
+#endif
 		return -1;
 	}
 	subrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));
@@ -570,8 +650,10 @@ int parse_rtattr(struct rtattr *tb[], in
 			tb[rta->rta_type] = rta;
 		rta = RTA_NEXT(rta,len);
 	}
+#ifdef NO_OPTSIZE
 	if (len)
 		fprintf(stderr, "!!!Deficit %d, rta_len=%d\n", len, rta->rta_len);
+#endif
 	return 0;
 }
 
@@ -585,7 +667,9 @@ int parse_rtattr_byindex(struct rtattr *
 			tb[i++] = rta;
 		rta = RTA_NEXT(rta,len);
 	}
+#ifdef NO_OPTSIZE
 	if (len)
 		fprintf(stderr, "!!!Deficit %d, rta_len=%d\n", len, rta->rta_len);
+#endif
 	return i;
 }
--- iproute2/lib/ll_addr.c
+++ iproute2/lib/ll_addr.c
@@ -62,7 +62,9 @@ int ll_addr_a2n(char *lladdr, int len, c
 	if (strchr(arg, '.')) {
 		inet_prefix pfx;
 		if (get_addr_1(&pfx, arg, AF_INET)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "\"%s\" is invalid lladdr.\n", arg);
+#endif
 			return -1;
 		}
 		if (len < 4)
@@ -80,11 +82,15 @@ int ll_addr_a2n(char *lladdr, int len, c
 				cp++;
 			}
 			if (sscanf(arg, "%x", &temp) != 1) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "\"%s\" is invalid lladdr.\n", arg);
+#endif
 				return -1;
 			}
 			if (temp < 0 || temp > 255) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "\"%s\" is invalid lladdr.\n", arg);
+#endif
 				return -1;
 			}
 			lladdr[i] = temp;
--- iproute2/lib/ll_map.c
+++ iproute2/lib/ll_map.c
@@ -161,12 +161,16 @@ unsigned ll_name_to_index(const char *na
 int ll_init_map(struct rtnl_handle *rth)
 {
 	if (rtnl_wilddump_request(rth, AF_UNSPEC, RTM_GETLINK) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot send dump request");
+#endif
 		exit(1);
 	}
 
 	if (rtnl_dump_filter(rth, ll_remember_index, &idxmap, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Dump terminated\n");
+#endif
 		exit(1);
 	}
 	return 0;
--- iproute2/lib/Makefile
+++ iproute2/lib/Makefile
@@ -3,6 +3,8 @@ UTILOBJ=utils.o rt_names.o ll_types.o ll
 
 NLOBJ=ll_map.o libnetlink.o
 
+LDFLAGS= -ffunction-sections -fdata-sections -Wl,--gc-sections
+
 all: libnetlink.a libutil.a
 
 libnetlink.a: $(NLOBJ)
--- iproute2/lib/rt_names.c
+++ iproute2/lib/rt_names.c
@@ -52,8 +52,10 @@ rtnl_hash_initialize(char *file, struct
 		    sscanf(p, "0x%x %s #", &id, namebuf) != 2 &&
 		    sscanf(p, "%d %s\n", &id, namebuf) != 2 &&
 		    sscanf(p, "%d %s #", &id, namebuf) != 2) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Database %s is corrupted at %s\n",
 				file, p);
+#endif
 			return;
 		}
 
@@ -89,8 +91,10 @@ static void rtnl_tab_initialize(char *fi
 		    sscanf(p, "0x%x %s #", &id, namebuf) != 2 &&
 		    sscanf(p, "%d %s\n", &id, namebuf) != 2 &&
 		    sscanf(p, "%d %s #", &id, namebuf) != 2) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Database %s is corrupted at %s\n",
 				file, p);
+#endif
 			return;
 		}
 
--- iproute2/lib/utils.c
+++ iproute2/lib/utils.c
@@ -257,11 +257,15 @@ done:
 int get_addr(inet_prefix *dst, const char *arg, int family)
 {
 	if (family == AF_PACKET) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Error: \"%s\" may be inet address, but it is not allowed in this context.\n", arg);
+#endif
 		exit(1);
 	}
 	if (get_addr_1(dst, arg, family)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Error: an inet address is expected rather than \"%s\".\n", arg);
+#endif
 		exit(1);
 	}
 	return 0;
@@ -270,11 +274,15 @@ int get_addr(inet_prefix *dst, const cha
 int get_prefix(inet_prefix *dst, char *arg, int family)
 {
 	if (family == AF_PACKET) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Error: \"%s\" may be inet prefix, but it is not allowed in this context.\n", arg);
+#endif
 		exit(1);
 	}
 	if (get_prefix_1(dst, arg, family)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Error: an inet prefix is expected rather than \"%s\".\n", arg);
+#endif
 		exit(1);
 	}
 	return 0;
@@ -284,7 +292,9 @@ __u32 get_addr32(const char *name)
 {
 	inet_prefix addr;
 	if (get_addr_1(&addr, name, AF_INET)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Error: an IP address is expected rather than \"%s\"\n", name);
+#endif
 		exit(1);
 	}
 	return addr.data[0];
@@ -292,31 +302,41 @@ __u32 get_addr32(const char *name)
 
 void incomplete_command(void)
 {
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Command line is not complete. Try option \"help\"\n");
+#endif
 	exit(-1);
 }
 
 void missarg(const char *key)
 {
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Error: argument \"%s\" is required\n", key);
+#endif
 	exit(-1);
 }
 
 void invarg(const char *msg, const char *arg)
 {
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Error: argument \"%s\" is wrong: %s\n", arg, msg);
+#endif
 	exit(-1);
 }
 
 void duparg(const char *key, const char *arg)
 {
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Error: duplicate \"%s\": \"%s\" is the second value.\n", key, arg);
+#endif
 	exit(-1);
 }
 
 void duparg2(const char *key, const char *arg)
 {
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Error: either \"%s\" is duplicate, or \"%s\" is a garbage.\n", key, arg);
+#endif
 	exit(-1);
 }
 
@@ -597,7 +617,9 @@ size_t getcmdline(char **linep, size_t *
 		size_t cc1;
 
 		if ((cc1 = getline(&line1, &len1, in)) < 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Missing continuation line\n");
+#endif
 			return cc1;
 		}
 
@@ -610,7 +632,9 @@ size_t getcmdline(char **linep, size_t *
 
 		*linep = realloc(*linep, strlen(*linep) + strlen(line1) + 1);
 		if (!*linep) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Out of memory\n");
+#endif
 			return -1;
 		}
 		cc += cc1 - 2;
@@ -629,7 +653,9 @@ int makeargs(char *line, char *argv[], i
 
 	for (cp = strtok(line, ws); cp; cp = strtok(NULL, ws)) {
 		if (argc >= (maxargs - 1)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Too many arguments to command\n");
+#endif
 			exit(1);
 		}
 		argv[argc++] = cp;
--- iproute2/tc/em_cmp.c
+++ iproute2/tc/em_cmp.c
@@ -28,6 +28,7 @@ extern struct ematch_util cmp_ematch_uti
 
 static void cmp_print_usage(FILE *fd)
 {
+#ifdef NO_OPTSIZE
 	fprintf(fd,
 	    "Usage: cmp(ALIGN at OFFSET [ ATTRS ] { eq | lt | gt } VALUE)\n" \
 	    "where: ALIGN  := { u8 | u16 | u32 }\n" \
@@ -36,6 +37,7 @@ static void cmp_print_usage(FILE *fd)
 	    "\n" \
 	    "Example: cmp(u16 at 3 layer 2 mask 0xff00 gt 20)\n",
 	    TCF_LAYER_MAX);
+#endif
 }
 
 static int cmp_parse_eopt(struct nlmsghdr *n, struct tcf_ematch_hdr *hdr,
@@ -148,7 +150,9 @@ static int cmp_print_eopt(FILE *fd, stru
 	struct tcf_em_cmp *cmp = data;
 
 	if (data_len < sizeof(*cmp)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "CMP header size mismatch\n");
+#endif
 		return -1;
 	}
 
--- iproute2/tc/em_meta.c
+++ iproute2/tc/em_meta.c
@@ -28,6 +28,7 @@ extern struct ematch_util meta_ematch_ut
 
 static void meta_print_usage(FILE *fd)
 {
+#ifdef NO_OPTSIZE
 	fprintf(fd,
 	    "Usage: meta(OBJECT { eq | lt | gt } OBJECT)\n" \
 	    "where: OBJECT  := { META_ID | VALUE }\n" \
@@ -39,6 +40,7 @@ static void meta_print_usage(FILE *fd)
 	    "         meta(dev eq indev)\n" \
 	    "\n" \
 	    "For a list of meta identifiers, use meta(list).\n");
+#endif
 }
 
 struct meta_entry {
@@ -119,7 +121,9 @@ static inline int map_type(char k)
 		case 'v': return TCF_META_TYPE_VAR;
 	}
 
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "BUG: Unknown map character '%c'\n", k);
+#endif
 	return INT_MAX;
 }
 
@@ -441,15 +445,19 @@ binary:
 static inline int print_value(FILE *fd, int type, struct rtattr *rta)
 {
 	if (rta == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Missing value TLV\n");
+#endif
 		return -1;
 	}
 
 	switch(type) {
 		case TCF_META_TYPE_INT:
 			if (RTA_PAYLOAD(rta) < sizeof(__u32)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "meta int type value TLV " \
 				    "size mismatch.\n");
+#endif
 				return -1;
 			}
 			fprintf(fd, "%d", *(__u32 *) RTA_DATA(rta));
@@ -497,7 +505,9 @@ static int print_object(FILE *fd, struct
 	return 0;
 
 size_mismatch:
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "meta int type mask TLV size mismatch\n");
+#endif
 	return -1;
 }
 
@@ -512,12 +522,16 @@ static int meta_print_eopt(FILE *fd, str
 		return -1;
 
 	if (tb[TCA_EM_META_HDR] == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Missing meta header\n");
+#endif
 		return -1;
 	}
 
 	if (RTA_PAYLOAD(tb[TCA_EM_META_HDR]) < sizeof(*meta_hdr)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Meta header size mismatch\n");
+#endif
 		return -1;
 	}
 
--- iproute2/tc/em_nbyte.c
+++ iproute2/tc/em_nbyte.c
@@ -28,6 +28,7 @@ extern struct ematch_util nbyte_ematch_u
 
 static void nbyte_print_usage(FILE *fd)
 {
+#ifdef NO_OPTSIZE
 	fprintf(fd,
 	    "Usage: nbyte(NEEDLE at OFFSET [layer LAYER])\n" \
 	    "where: NEEDLE := { string | \"c-escape-sequence\" }\n" \
@@ -36,6 +37,7 @@ static void nbyte_print_usage(FILE *fd)
 	    "\n" \
 	    "Example: nbyte(\"ababa\" at 12 layer 1)\n",
 	    TCF_LAYER_MAX);
+#endif
 }
 
 static int nbyte_parse_eopt(struct nlmsghdr *n, struct tcf_ematch_hdr *hdr,
@@ -113,12 +115,16 @@ static int nbyte_print_eopt(FILE *fd, st
 	__u8 *needle;
 
 	if (data_len < sizeof(*nb)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "NByte header size mismatch\n");
+#endif
 		return -1;
 	}
 
 	if (data_len < sizeof(*nb) + nb->len) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "NByte payload size mismatch\n");
+#endif
 		return -1;
 	}
 
--- iproute2/tc/em_u32.c
+++ iproute2/tc/em_u32.c
@@ -27,11 +27,13 @@ extern struct ematch_util u32_ematch_uti
 
 static void u32_print_usage(FILE *fd)
 {
+#ifdef NO_OPTSIZE
 	fprintf(fd,
 	    "Usage: u32(ALIGN VALUE MASK at [ nexthdr+ ] OFFSET)\n" \
 	    "where: ALIGN  := { u8 | u16 | u32 }\n" \
 	    "\n" \
 	    "Example: u32(u16 0x1122 0xffff at nexthdr+4)\n");
+#endif
 }
 
 static int u32_parse_eopt(struct nlmsghdr *n, struct tcf_ematch_hdr *hdr,
@@ -156,7 +158,9 @@ static int u32_print_eopt(FILE *fd, stru
 	struct tc_u32_key *u_key = data;
 
 	if (data_len < sizeof(*u_key)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "U32 header size mismatch\n");
+#endif
 		return -1;
 	}
 
--- iproute2/tc/f_basic.c
+++ iproute2/tc/f_basic.c
@@ -25,6 +25,7 @@
 #include "tc_util.h"
 #include "m_ematch.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... basic [ match EMATCH_TREE ] [ police POLICE_SPEC ]\n");
@@ -33,6 +34,9 @@ static void explain(void)
 	fprintf(stderr, "Where: SELECTOR := SAMPLE SAMPLE ...\n");
 	fprintf(stderr, "       FILTERID := X:Y:Z\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 static int basic_parse_opt(struct filter_util *qu, char *handle,
 			   int argc, char **argv, struct nlmsghdr *n)
@@ -47,8 +51,10 @@ static int basic_parse_opt(struct filter
 	if (handle) {
 		h = strtol(handle, NULL, 0);
 		if (h == LONG_MIN || h == LONG_MAX) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Illegal handle \"%s\", must be numeric.\n",
 			    handle);
+#endif
 			return -1;
 		}
 	}
@@ -62,7 +68,9 @@ static int basic_parse_opt(struct filter
 		if (matches(*argv, "match") == 0) {
 			NEXT_ARG();
 			if (parse_ematch(&argc, &argv, TCA_BASIC_EMATCHES, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"ematch\"\n");
+#endif
 				return -1;
 			}
 			continue;
@@ -71,14 +79,18 @@ static int basic_parse_opt(struct filter
 			unsigned handle;
 			NEXT_ARG();
 			if (get_tc_classid(&handle, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"classid\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, MAX_MSG, TCA_BASIC_CLASSID, &handle, 4);
 		} else if (matches(*argv, "action") == 0) {
 			NEXT_ARG();
 			if (parse_action(&argc, &argv, TCA_BASIC_ACT, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"action\"\n");
+#endif
 				return -1;
 			}
 			continue;
@@ -86,7 +98,9 @@ static int basic_parse_opt(struct filter
 		} else if (matches(*argv, "police") == 0) {
 			NEXT_ARG();
 			if (parse_police(&argc, &argv, TCA_BASIC_POLICE, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"police\"\n");
+#endif
 				return -1;
 			}
 			continue;
@@ -94,7 +108,9 @@ static int basic_parse_opt(struct filter
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
--- iproute2/tc/f_fw.c
+++ iproute2/tc/f_fw.c
@@ -23,12 +23,16 @@
 #include "utils.h"
 #include "tc_util.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... fw [ classid CLASSID ] [ police POLICE_SPEC ]\n");
 	fprintf(stderr, "       POLICE_SPEC := ... look at TBF\n");
 	fprintf(stderr, "       CLASSID := X:Y\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 #define usage() return(-1)
 
@@ -42,7 +46,9 @@ static int fw_parse_opt(struct filter_ut
 
 	if (handle) {
 		if (get_u32(&t->tcm_handle, handle, 0)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Illegal \"handle\"\n");
+#endif
 			return -1;
 		}
 	}
@@ -59,21 +65,27 @@ static int fw_parse_opt(struct filter_ut
 			unsigned handle;
 			NEXT_ARG();
 			if (get_tc_classid(&handle, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"classid\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, 4096, TCA_FW_CLASSID, &handle, 4);
 		} else if (matches(*argv, "police") == 0) {
 			NEXT_ARG();
 			if (parse_police(&argc, &argv, TCA_FW_POLICE, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"police\"\n");
+#endif
 				return -1;
 			}
 			continue;
 		} else if (matches(*argv, "action") == 0) {
 			NEXT_ARG();
 			if (parse_action(&argc, &argv, TCA_FW_ACT, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal fw \"action\"\n");
+#endif
 				return -1;
 			}
 			continue;
@@ -83,7 +95,9 @@ static int fw_parse_opt(struct filter_ut
 			argc--;
 			argv++;
 			if (argc < 1) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal indev\n");
+#endif
 				return -1;
 			}
 			strncpy(d, *argv, sizeof (d) - 1);
@@ -92,7 +106,9 @@ static int fw_parse_opt(struct filter_ut
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
--- iproute2/tc/f_route.c
+++ iproute2/tc/f_route.c
@@ -25,6 +25,7 @@
 #include "tc_common.h"
 #include "tc_util.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... route [ from REALM | fromif TAG ] [ to REALM ]\n");
@@ -32,6 +33,9 @@ static void explain(void)
 	fprintf(stderr, "       POLICE_SPEC := ... look at TBF\n");
 	fprintf(stderr, "       CLASSID := X:Y\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 #define usage() return(-1)
 
@@ -47,7 +51,9 @@ static int route_parse_opt(struct filter
 
 	if (handle) {
 		if (get_u32(&t->tcm_handle, handle, 0)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Illegal \"handle\"\n");
+#endif
 			return -1;
 		}
 	}
@@ -63,7 +69,9 @@ static int route_parse_opt(struct filter
 			__u32 id;
 			NEXT_ARG();
 			if (rtnl_rtrealm_a2n(&id, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"to\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, 4096, TCA_ROUTE4_TO, &id, 4);
@@ -73,7 +81,9 @@ static int route_parse_opt(struct filter
 			__u32 id;
 			NEXT_ARG();
 			if (rtnl_rtrealm_a2n(&id, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"from\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, 4096, TCA_ROUTE4_FROM, &id, 4);
@@ -84,7 +94,9 @@ static int route_parse_opt(struct filter
 			NEXT_ARG();
 			ll_init_map(&rth);
 			if ((id=ll_name_to_index(*argv)) <= 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"fromif\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, 4096, TCA_ROUTE4_IIF, &id, 4);
@@ -95,28 +107,36 @@ static int route_parse_opt(struct filter
 			unsigned handle;
 			NEXT_ARG();
 			if (get_tc_classid(&handle, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"classid\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, 4096, TCA_ROUTE4_CLASSID, &handle, 4);
 		} else if (matches(*argv, "police") == 0) {
 			NEXT_ARG();
 			if (parse_police(&argc, &argv, TCA_ROUTE4_POLICE, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"police\"\n");
+#endif
 				return -1;
 			}
 			continue;
 		} else if (matches(*argv, "order") == 0) {
 			NEXT_ARG();
 			if (get_u32(&order, *argv, 0)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"order\"\n");
+#endif
 				return -1;
 			}
 		} else if (strcmp(*argv, "help") == 0) {
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
--- iproute2/tc/f_rsvp.c
+++ iproute2/tc/f_rsvp.c
@@ -24,6 +24,7 @@
 #include "utils.h"
 #include "tc_util.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... rsvp ipproto PROTOCOL session DST[/PORT | GPI ]\n");
@@ -35,6 +36,9 @@ static void explain(void)
 	fprintf(stderr, "       POLICE_SPEC := ... look at TBF\n");
 	fprintf(stderr, "       FILTERID := X:Y\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 #define usage() return(-1)
 
@@ -181,7 +185,9 @@ static int rsvp_parse_opt(struct filter_
 
 	if (handle) {
 		if (get_u32(&t->tcm_handle, handle, 0)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Illegal \"handle\"\n");
+#endif
 			return -1;
 		}
 	}
@@ -197,7 +203,9 @@ static int rsvp_parse_opt(struct filter_
 			inet_prefix addr;
 			NEXT_ARG();
 			if (get_addr_and_pi(&argc, &argv, &addr, &pinfo, 1, family)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"session\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, 4096, TCA_RSVP_DST, &addr.data, addr.bytelen);
@@ -209,7 +217,9 @@ static int rsvp_parse_opt(struct filter_
 			inet_prefix addr;
 			NEXT_ARG();
 			if (get_addr_and_pi(&argc, &argv, &addr, &pinfo, 0, family)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"sender\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, 4096, TCA_RSVP_SRC, &addr.data, addr.bytelen);
@@ -221,7 +231,9 @@ static int rsvp_parse_opt(struct filter_
 			NEXT_ARG();
 			num = inet_proto_a2n(*argv);
 			if (num < 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"ipproto\"\n");
+#endif
 				return -1;
 			}
 			pinfo.protocol = num;
@@ -231,7 +243,9 @@ static int rsvp_parse_opt(struct filter_
 			unsigned handle;
 			NEXT_ARG();
 			if (get_tc_classid(&handle, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"classid\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, 4096, TCA_RSVP_CLASSID, &handle, 4);
@@ -239,7 +253,9 @@ static int rsvp_parse_opt(struct filter_
 			unsigned tid;
 			NEXT_ARG();
 			if (get_unsigned(&tid, *argv, 0)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"tunnelid\"\n");
+#endif
 				return -1;
 			}
 			pinfo.tunnelid = tid;
@@ -248,7 +264,9 @@ static int rsvp_parse_opt(struct filter_
 			unsigned tid;
 			NEXT_ARG();
 			if (get_unsigned(&tid, *argv, 0)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"tunnel\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, 4096, TCA_RSVP_CLASSID, &tid, 4);
@@ -257,7 +275,9 @@ static int rsvp_parse_opt(struct filter_
 				NEXT_ARG();
 			}
 			if (get_unsigned(&tid, *argv, 0)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"skip\"\n");
+#endif
 				return -1;
 			}
 			pinfo.tunnelhdr = tid;
@@ -265,7 +285,9 @@ static int rsvp_parse_opt(struct filter_
 		} else if (matches(*argv, "police") == 0) {
 			NEXT_ARG();
 			if (parse_police(&argc, &argv, TCA_RSVP_POLICE, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"police\"\n");
+#endif
 				return -1;
 			}
 			continue;
@@ -273,7 +295,9 @@ static int rsvp_parse_opt(struct filter_
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
--- iproute2/tc/f_tcindex.c
+++ iproute2/tc/f_tcindex.c
@@ -15,6 +15,7 @@
 #include "utils.h"
 #include "tc_util.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr," Usage: ... tcindex [ hash SIZE ] [ mask MASK ]"
@@ -23,6 +24,9 @@ static void explain(void)
 	fprintf(stderr,"                    [ classid CLASSID ] "
 	    "[ police POLICE_SPEC ]\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 
 #define usage() return(-1)
@@ -38,7 +42,9 @@ static int tcindex_parse_opt(struct filt
 	if (handle) {
 		t->tcm_handle = strtoul(handle,&end,0);
 		if (*end) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Illegal filter ID\n");
+#endif
 			return -1;
 		}
 	}
@@ -97,7 +103,9 @@ static int tcindex_parse_opt(struct filt
 
 			NEXT_ARG();
 			if (get_tc_classid(&handle,*argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"classid\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, 4096, TCA_TCINDEX_CLASSID, &handle, 4);
@@ -105,7 +113,9 @@ static int tcindex_parse_opt(struct filt
 		else if (!strcmp(*argv,"police")) {
 			NEXT_ARG();
 			if (parse_police(&argc, &argv, TCA_TCINDEX_POLICE, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"police\"\n");
+#endif
 				return -1;
 			}
 			continue;
--- iproute2/tc/f_u32.c
+++ iproute2/tc/f_u32.c
@@ -25,6 +25,7 @@
 #include "utils.h"
 #include "tc_util.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... u32 [ match SELECTOR ... ] [ link HTID ] [ classid CLASSID ]\n");
@@ -37,6 +38,9 @@ static void explain(void)
 	fprintf(stderr, "       SAMPLE := { ip | ip6 | udp | tcp | icmp | u{32|16|8} | mark } SAMPLE_ARGS [divisor DIVISOR]\n");
 	fprintf(stderr, "       FILTERID := X:Y:Z\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 #define usage() return(-1)
 
@@ -602,19 +606,25 @@ static int parse_mark(int *argc_p, char
 		return -1;
 
 	if (get_u32(&mark.val, *argv, 0)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Illegal \"mark\" value\n");
+#endif
 		return -1;
 	}
 	NEXT_ARG();
 
 	if (get_u32(&mark.mask, *argv, 0)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Illegal \"mark\" mask\n");
+#endif
 		return -1;
 	}
 	NEXT_ARG();
 
 	if ((mark.val & mark.mask) != mark.val) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Illegal \"mark\" (impossible combination)\n");
+#endif
 		return -1;
 	}
 
@@ -709,7 +719,9 @@ static int parse_offset(int *argc_p, cha
 				return -1;
 			sel->offoff = off;
 			if (off%2) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "offset \"at\" must be even\n");
+#endif
 				return -1;
 			}
 			sel->flags |= TC_U32_VAROFFSET;
@@ -787,7 +799,9 @@ static int u32_parse_opt(struct filter_u
 	memset(&sel, 0, sizeof(sel));
 
 	if (handle && get_u32_handle(&t->tcm_handle, handle)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Illegal filter ID\n");
+#endif
 		return -1;
 	}
 
@@ -801,7 +815,9 @@ static int u32_parse_opt(struct filter_u
 		if (matches(*argv, "match") == 0) {
 			NEXT_ARG();
 			if (parse_selector(&argc, &argv, &sel.sel, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"match\"\n");
+#endif
 				return -1;
 			}
 			sel_ok++;
@@ -809,14 +825,18 @@ static int u32_parse_opt(struct filter_u
 		} else if (matches(*argv, "offset") == 0) {
 			NEXT_ARG();
 			if (parse_offset(&argc, &argv, &sel.sel)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"offset\"\n");
+#endif
 				return -1;
 			}
 			continue;
 		} else if (matches(*argv, "hashkey") == 0) {
 			NEXT_ARG();
 			if (parse_hashkey(&argc, &argv, &sel.sel)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"hashkey\"\n");
+#endif
 				return -1;
 			}
 			continue;
@@ -825,7 +845,9 @@ static int u32_parse_opt(struct filter_u
 			unsigned handle;
 			NEXT_ARG();
 			if (get_tc_classid(&handle, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"classid\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, MAX_MSG, TCA_U32_CLASSID, &handle, 4);
@@ -836,25 +858,33 @@ static int u32_parse_opt(struct filter_u
 			if (get_unsigned(&divisor, *argv, 0) ||
 			    divisor == 0 ||
 			    divisor > 0x100 || ((divisor - 1) & divisor)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"divisor\"\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, MAX_MSG, TCA_U32_DIVISOR, &divisor, 4);
 		} else if (matches(*argv, "order") == 0) {
 			NEXT_ARG();
 			if (get_u32(&order, *argv, 0)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"order\"\n");
+#endif
 				return -1;
 			}
 		} else if (strcmp(*argv, "link") == 0) {
 			unsigned handle;
 			NEXT_ARG();
 			if (get_u32_handle(&handle, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"link\"\n");
+#endif
 				return -1;
 			}
 			if (handle && TC_U32_NODE(handle)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "\"link\" must be a hash table.\n");
+#endif
 				return -1;
 			}
 			addattr_l(n, MAX_MSG, TCA_U32_LINK, &handle, 4);
@@ -862,11 +892,15 @@ static int u32_parse_opt(struct filter_u
 			unsigned handle;
 			NEXT_ARG();
 			if (get_u32_handle(&handle, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"ht\"\n");
+#endif
 				return -1;
 			}
 			if (handle && TC_U32_NODE(handle)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "\"ht\" must be a hash table.\n");
+#endif
 				return -1;
 			}
 			if (sample_ok)
@@ -884,18 +918,24 @@ static int u32_parse_opt(struct filter_u
 			memset(&sel2, 0, sizeof(sel2));
 			NEXT_ARG();
 			if (parse_selector(&argc, &argv, &sel2.sel, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"sample\"\n");
+#endif
 				return -1;
 			}
 			if (sel2.sel.nkeys != 1) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "\"sample\" must contain exactly ONE key.\n");
+#endif
 				return -1;
 			}
 			if (*argv != 0 && strcmp(*argv, "divisor") == 0) {
 				NEXT_ARG();
 				if (get_unsigned(&divisor, *argv, 0) || divisor == 0 ||
 				    divisor > 0x100 || ((divisor - 1) & divisor)) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "Illegal sample \"divisor\"\n");
+#endif
 					return -1;
 				}
 				NEXT_ARG();
@@ -912,7 +952,9 @@ static int u32_parse_opt(struct filter_u
 			argc--;
 			argv++;
 			if (argc < 1) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal indev\n");
+#endif
 				return -1;
 			}
 			strncpy(ind, *argv, sizeof (ind) - 1);
@@ -921,7 +963,9 @@ static int u32_parse_opt(struct filter_u
 		} else if (matches(*argv, "action") == 0) {
 			NEXT_ARG();
 			if (parse_action(&argc, &argv, TCA_U32_ACT, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"action\"\n");
+#endif
 				return -1;
 			}
 			terminal_ok++;
@@ -930,7 +974,9 @@ static int u32_parse_opt(struct filter_u
 		} else if (matches(*argv, "police") == 0) {
 			NEXT_ARG();
 			if (parse_police(&argc, &argv, TCA_U32_POLICE, n)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"police\"\n");
+#endif
 				return -1;
 			}
 			terminal_ok++;
@@ -939,7 +985,9 @@ static int u32_parse_opt(struct filter_u
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
@@ -952,7 +1000,9 @@ static int u32_parse_opt(struct filter_u
 	
 	if (order) {
 		if (TC_U32_NODE(t->tcm_handle) && order != TC_U32_NODE(t->tcm_handle)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "\"order\" contradicts \"handle\"\n");
+#endif
 			return -1;
 		}
 		t->tcm_handle |= order;
--- iproute2/tc/m_action.c
+++ iproute2/tc/m_action.c
@@ -35,6 +35,7 @@ int gact_ld = 0 ; //fuckin backward comp
 int batch_c = 0;
 int tab_flush = 0;
 
+#ifdef NO_OPTSIZE
 void act_usage(void)
 {
 	/*XXX: In the near future add a action->print_help to improve
@@ -61,6 +62,9 @@ void act_usage(void)
 
 	exit(-1);
 }
+#else
+#define act_usage() exit(-1)
+#endif /* NO_OPTSIZE */
 
 static int print_noaopt(struct action_util *au, FILE *f, struct rtattr *opt)
 {
@@ -73,12 +77,18 @@ static int print_noaopt(struct action_ut
 static int parse_noaopt(struct action_util *au, int *argc_p, char ***argv_p, int code, struct nlmsghdr *n)
 {
 	int argc = *argc_p;
+#ifdef NO_OPTSIZE
 	char **argv = *argv_p;
+#endif
 
 	if (argc) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Unknown action \"%s\", hence option \"%s\" is unparsable\n", au->id, *argv);
+#endif
 	} else {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Unknown action \"%s\"\n", au->id);
+#endif
 	}
 	return -1;
 }
@@ -214,7 +224,9 @@ done0:
 			ret = a->parse_aopt(a,&argc, &argv, TCA_ACT_OPTIONS, n);
 
 			if (ret < 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr,"bad action parsing\n");
+#endif
 				goto bad_val;
 			}
 			tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
@@ -224,7 +236,9 @@ done0:
 	}
 
 	if (eap > 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"bad action empty %d\n",eap);
+#endif
 		goto bad_val;
 	}
 
@@ -237,7 +251,9 @@ done:
 bad_val:
 	/* no need to undo things, returning from here should
 	 * cause enough pain */
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "parse_action: bad value (%d:%s)!\n",argc,*argv);
+#endif
 	return -1;
 }
 
@@ -254,7 +270,9 @@ tc_print_one_action(FILE * f, struct rta
 
 	parse_rtattr_nested(tb, TCA_ACT_MAX, arg);
 	if (tb[TCA_ACT_KIND] == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "NULL Action!\n");
+#endif
 		return -1;
 	}
 
@@ -327,15 +345,20 @@ int print_action(const struct sockaddr_n
 	len -= NLMSG_LENGTH(sizeof(*t));
 
 	if (len < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Wrong len %d\n", len);
+#endif
 		return -1;
 	}
 
 	parse_rtattr(tb, TCAA_MAX, TA_RTA(t), len);
 
 	if (NULL == tb[TCA_ACT_TAB]) {
-		if (n->nlmsg_type != RTM_GETACTION)
+		if (n->nlmsg_type != RTM_GETACTION) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "print_action: NULL kind\n");
+#endif
+		}
 		return -1;
 	}
 
@@ -404,12 +427,16 @@ int tc_action_gd(int cmd, unsigned flags
 		strncpy(k, *argv, sizeof (k) - 1);
 		a = get_action_kind(k);
 		if (NULL == a) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Error: non existent action: %s\n",k);
+#endif
 			ret = -1;
 			goto bad_val;
 		}
 		if (strcmp(a->id, k) != 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Error: non existent action: %s\n",k);
+#endif
 			ret = -1;
 			goto bad_val;
 		}
@@ -417,7 +444,9 @@ int tc_action_gd(int cmd, unsigned flags
 		argc -=1;
 		argv +=1;
 		if (argc <= 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Error: no index specified action: %s\n",k);
+#endif
 			ret = -1;
 			goto bad_val;
 		}
@@ -425,14 +454,18 @@ int tc_action_gd(int cmd, unsigned flags
 		if (matches(*argv, "index") == 0) {
 			NEXT_ARG();
 			if (get_u32(&i, *argv, 10)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"index\"\n");
+#endif
 				ret = -1;
 				goto bad_val;
 			}
 			argc -=1;
 			argv +=1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Error: no index specified action: %s\n",k);
+#endif
 			ret = -1;
 			goto bad_val;
 		}
@@ -452,12 +485,16 @@ int tc_action_gd(int cmd, unsigned flags
 		ans = &req.n;
 
 	if (rtnl_talk(&rth, &req.n, 0, 0, ans, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "We have an error talking to the kernel\n");
+#endif
 		return 1;
 	}
 
 	if (ans && print_action(NULL, &req.n, (void*)stdout) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Dump terminated\n");
+#endif
 		return 1;
 	}
 
@@ -491,13 +528,17 @@ int tc_action_modify(int cmd, unsigned f
 	argc -=1;
 	argv +=1;
 	if (parse_action(&argc, &argv, TCA_ACT_TAB, &req.n)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Illegal \"action\"\n");
+#endif
 		return -1;
 	}
 	tail->rta_len = (void *) NLMSG_TAIL(&req.n) - (void *) tail;
 
 	if (rtnl_talk(&rth, &req.n, 0, 0, NULL, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "We have an error talking to the kernel\n");
+#endif
 		ret = -1;
 	}
 
@@ -537,11 +578,15 @@ int tc_act_list_or_flush(int argc, char
 #endif
 	a = get_action_kind(k);
 	if (NULL == a) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"bad action %s\n",k);
+#endif
 		goto bad_val;
 	}
 	if (strcmp(a->id, k) != 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"bad action %s\n",k);
+#endif
 		goto bad_val;
 	}
 	strncpy(k, *argv, sizeof (k) - 1);
@@ -555,7 +600,9 @@ int tc_act_list_or_flush(int argc, char
 
 	if (event == RTM_GETACTION) {
 		if (rtnl_dump_request(&rth, event, (void *)&req.t, msg_size) < 0) {
+#ifdef NO_OPTSIZE
 			perror("Cannot send dump request");
+#endif
 			return 1;
 		}
 		ret = rtnl_dump_filter(&rth, print_action, stdout, NULL, NULL);
@@ -567,7 +614,9 @@ int tc_act_list_or_flush(int argc, char
 		req.n.nlmsg_flags |= NLM_F_ROOT;
 		req.n.nlmsg_flags |= NLM_F_REQUEST;
 		if (rtnl_talk(&rth, &req.n, 0, 0, NULL, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "We have an error flushing\n");
+#endif
 			return 1;
 		}
 
@@ -620,7 +669,9 @@ int do_action(int argc, char **argv)
 		}
 
 		if (ret < 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Command \"%s\" is unknown, try \"tc actions help\".\n", *argv);
+#endif
 			return -1;
 		}
 	}
--- iproute2/tc/m_ematch.c
+++ iproute2/tc/m_ematch.c
@@ -41,12 +41,14 @@ static char **begin_argv;
 
 static inline void map_warning(int num, char *kind)
 {
+#ifdef NO_OPTSIZE
 	fprintf(stderr,
 	    "Error: Unable to find ematch \"%s\" in %s\n" \
 	    "Please assign a unique ID to the ematch kind the suggested " \
 	    "entry is:\n" \
 	    "\t%d\t%s\n",
 	    kind, EMATCH_MAP, num, kind);
+#endif
 }
 
 static int lookup_map(__u16 num, char *dst, int len, const char *file)
@@ -68,8 +70,10 @@ static int lookup_map(__u16 num, char *d
 			continue;
 
 		if (sscanf(p, "%d %s", &id, namebuf) != 2) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "ematch map %s corrupted at %s\n",
 			    file, p);
+#endif
 			goto out;
 		}
 
@@ -106,8 +110,10 @@ static int lookup_map_id(char *kind, int
 			continue;
 
 		if (sscanf(p, "%d %s", &id, namebuf) != 2) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "ematch map %s corrupted at %s\n",
 			    file, p);
+#endif
 			goto out;
 		}
 
@@ -203,8 +209,10 @@ static int parse_tree(struct nlmsghdr *n
 			strncpy(buf, (char*) t->args->data, sizeof(buf)-1);
 			e = get_ematch_kind(buf);
 			if (e == NULL) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Unknown ematch \"%s\"\n",
 				    buf);
+#endif
 				return -1;
 			}
 
@@ -295,6 +303,7 @@ int em_parse_error(int err, struct bstr
 	}
 
 	if (e == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,
 		    "Usage: EXPR\n" \
 		    "where: EXPR  := TERM [ { and | or } EXPR ]\n" \
@@ -303,6 +312,7 @@ int em_parse_error(int err, struct bstr
 		    "       ARGS := ARG1 ARG2 ...\n" \
 		    "\n" \
 		    "Example: a(x y) and not (b(x) or c(x y z))\n");
+#endif
 	} else
 		e->print_usage(stderr);
 
@@ -473,17 +483,23 @@ int print_ematch(FILE *fd, const struct
 		return -1;
 
 	if (tb[TCA_EMATCH_TREE_HDR] == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Missing ematch tree header\n");
+#endif
 		return -1;
 	}
 
 	if (tb[TCA_EMATCH_TREE_LIST] == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Missing ematch tree list\n");
+#endif
 		return -1;
 	}
 
 	if (RTA_PAYLOAD(tb[TCA_EMATCH_TREE_HDR]) < sizeof(*hdr)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Ematch tree header size mismatch\n");
+#endif
 		return -1;
 	}
 
--- iproute2/tc/m_estimator.c
+++ iproute2/tc/m_estimator.c
@@ -23,6 +23,7 @@
 #include "utils.h"
 #include "tc_util.h"
 
+#ifdef NO_OPTSIZE
 static void est_help(void);
 
 static void est_help(void)
@@ -33,6 +34,9 @@ static void est_help(void)
 	fprintf(stderr, "Example: ... est 1sec 8sec\n");
 	return;
 }
+#else
+#define est_help()
+#endif /* NO_OPTSIZE */
 
 int parse_estimator(int *p_argc, char ***p_argv, struct tc_estimator *est)
 {
@@ -53,11 +57,15 @@ int parse_estimator(int *p_argc, char **
 	if (get_time(&time_const, *argv))
 		invarg("estimator", "invalid estimator time constant");
 	if (tc_setup_estimator(A, time_const, est) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Error: estimator parameters are out of range.\n");
+#endif
 		return -1;
 	}
+#ifdef NO_OPTSIZE
 	if (show_raw)
 		fprintf(stderr, "[estimator i=%u e=%u]\n", est->interval, est->ewma_log);
+#endif
 	*p_argc = argc;
 	*p_argv = argv;
 	return 0;
--- iproute2/tc/m_gact.c
+++ iproute2/tc/m_gact.c
@@ -39,6 +39,7 @@ static const char *prob_n2a(int p)
 }
 #endif
 
+#ifdef NO_OPTSIZE
 static void
 explain(void)
 {
@@ -59,6 +60,9 @@ explain(void)
 		"\n");
 #endif
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 
 static void
@@ -84,7 +88,9 @@ get_act(char ***argv_p)
 	} else if (matches(*argv, "pass") == 0 || matches(*argv, "ok") == 0)  {
 		return TC_ACT_OK;
 	} else {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"bad action type %s\n",*argv);
+#endif
 		return -10;
 	}
 }
@@ -140,7 +146,9 @@ parse_gact(struct action_util *a, int *a
 				NEXT_ARG();
 				pp.ptype = PGACT_DETERM;
 			} else {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"random type\"\n");
+#endif
 				return -1;
 			}
 
@@ -154,11 +162,15 @@ parse_gact(struct action_util *a, int *a
 			argc--;
 			argv++;
 			if (get_u16(&pp.pval, *argv, 10)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal probability val 0x%x\n",pp.pval);
+#endif
 				return -1;
 			}
 			if (pp.pval > 10000) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal probability val  0x%x\n",pp.pval);
+#endif
 				return -1;
 			}
 			argc--;
@@ -173,7 +185,9 @@ parse_gact(struct action_util *a, int *a
 		if (matches(*argv, "index") == 0) {
 			NEXT_ARG();
 			if (get_u32(&p.index, *argv, 10)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"index\"\n");
+#endif
 				return -1;
 			}
 			argc--;
--- iproute2/tc/m_ipt.c
+++ iproute2/tc/m_ipt.c
@@ -33,9 +33,11 @@
 #include <fcntl.h>
 #include <sys/wait.h>
 
-static const char *pname = "tc-ipt";
 static const char *tname = "mangle";
+#ifdef NO_OPTSIZE
+static const char *pname = "tc-ipt";
 static const char *pversion = "0.1";
+#endif
 
 static const char *ipthooks[] = {
 	"NF_IP_PRE_ROUTING",
@@ -67,6 +69,7 @@ register_target(struct iptables_target *
 
 }
 
+#ifdef NO_OPTSIZE
 void
 exit_tryhelp(int status)
 {
@@ -92,6 +95,11 @@ exit_error(enum exittype status, char *m
 			"Perhaps iptables or your kernel needs to be upgraded.\n");
 	exit(status);
 }
+#else
+#define exit_tryhelp(status) exit(status)
+#define exit_error(status, msg, ...) exit(status)
+#endif /* NO_OPTSIZE */
+
 
 /* stolen from iptables 1.2.11
 They should really have them as a library so i can link to them
@@ -191,7 +199,9 @@ fw_calloc(size_t count, size_t size)
 	void *p;
 
 	if ((p = (void *) calloc(count, size)) == NULL) {
+#ifdef NO_OPTSIZE
 		perror("iptables: calloc failed");
+#endif
 		exit(1);
 	}
 	return p;
@@ -267,8 +277,10 @@ get_target_name(const char *name)
 			if (NULL == m) {
 				m = find_t(lname);
 				if (NULL == m) {
+#ifdef NO_OPTSIZE
 					fputs(error, stderr);
 					fprintf(stderr, "\n");
+#endif
 					dlclose(handle);
 					return NULL;
 				}
@@ -386,7 +398,9 @@ static int parse_ipt(struct action_util
 	}
 
 	if (argc <= 2) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"bad arguements to ipt %d vs %d \n", argc, rargc);
+#endif
 		return -1;
 	}
 
@@ -407,7 +421,9 @@ static int parse_ipt(struct action_util
 				    merge_options(opts, m->extra_opts,
 						  &m->option_offset);
 			} else {
+#ifdef NO_OPTSIZE
 				fprintf(stderr," failed to find target %s\n\n", optarg);
+#endif
 				return -1;
 			}
 			ok++;
@@ -419,7 +435,9 @@ static int parse_ipt(struct action_util
 				m->parse(c - m->option_offset, argv, 0,
 					 &m->tflags, NULL, &m->t);
 			} else {
+#ifdef NO_OPTSIZE
 				fprintf(stderr," failed to find target %s\n\n", optarg);
+#endif
 				return -1;
 
 			}
@@ -432,7 +450,9 @@ static int parse_ipt(struct action_util
 	if (iargc > optind) {
 		if (matches(argv[optind], "index") == 0) {
 			if (get_u32(&index, argv[optind + 1], 10)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"index\"\n");
+#endif
 				free_opts(opts);
 				return -1;
 			}
@@ -443,7 +463,9 @@ static int parse_ipt(struct action_util
 	}
 
 	if (!ok && !iok) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr," ipt Parser BAD!! (%s)\n", *argv);
+#endif
 		return -1;
 	}
 
@@ -537,7 +559,9 @@ print_ipt(struct action_util *au,FILE *
 		m = get_target_name(t->u.user.name);
 		if (NULL != m) {
 			if (0 > build_st(m, t)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, " %s error \n", m->name);
+#endif
 				return -1;
 			}
 
@@ -545,8 +569,10 @@ print_ipt(struct action_util *au,FILE *
 			    merge_options(opts, m->extra_opts,
 					  &m->option_offset);
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, " failed to find target %s\n\n",
 				t->u.user.name);
+#endif
 			return -1;
 		}
 		fprintf(f, "\ttarget ");
--- iproute2/tc/m_mirred.c
+++ iproute2/tc/m_mirred.c
@@ -28,6 +28,7 @@
 
 int mirred_d = 1;
 
+#ifdef NO_OPTSIZE
 static void
 explain(void)
 {
@@ -39,6 +40,9 @@ explain(void)
 	fprintf(stderr, "\tDEVICENAME is the devicename \n");
 
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 static void
 usage(void)
@@ -90,7 +94,9 @@ parse_egress(struct action_util *a, int
 			if (matches(*argv, "index") == 0) {
 				NEXT_ARG();
 				if (get_u32(&p.index, *argv, 10)) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "Illegal \"index\"\n");
+#endif
 					return -1;
 				}
 				iok++;
@@ -100,13 +106,17 @@ parse_egress(struct action_util *a, int
 					break;
 				}
 			} else if(!ok) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "was expecting egress (%s)\n", *argv);
+#endif
 				break;
 
 			} else if (!mirror && matches(*argv, "mirror") == 0) {
 				mirror=1;
 				if (redir) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "Cant have both mirror and redir\n");
+#endif
 					return -1;
 				}
 				p.eaction = TCA_EGRESS_MIRROR;
@@ -115,7 +125,9 @@ parse_egress(struct action_util *a, int
 			} else if (!redir && matches(*argv, "redirect") == 0) {
 				redir=1;
 				if (mirror) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "Cant have both mirror and redir\n");
+#endif
 					return -1;
 				}
 				p.eaction = TCA_EGRESS_REDIR;
@@ -149,7 +161,9 @@ parse_egress(struct action_util *a, int
 		ll_init_map(&rth);
 
 		if ((idx = ll_name_to_index(d)) == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Cannot find device \"%s\"\n", d);
+#endif
 			return -1;
 		}
 
@@ -181,13 +195,17 @@ parse_egress(struct action_util *a, int
 
 	if (argc) {
 		if (iok && matches(*argv, "index") == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "mirred: Illegal double index\n");
+#endif
 			return -1;
 		} else {
 			if (matches(*argv, "index") == 0) {
 				NEXT_ARG();
 				if (get_u32(&p.index, *argv, 10)) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr, "mirred: Illegal \"index\"\n");
+#endif
 					return -1;
 				}
 				argc--;
@@ -218,14 +236,18 @@ parse_mirred(struct action_util *a, int
 	char **argv = *argv_p;
 
 	if (argc < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"mirred bad arguement count %d\n", argc);
+#endif
 		return -1;
 	}
 
 	if (matches(*argv, "mirred") == 0) {
 		NEXT_ARG();
 	} else {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"mirred bad arguement %s\n", *argv);
+#endif
 		return -1;
 	}
 
@@ -239,11 +261,15 @@ parse_mirred(struct action_util *a, int
 		}
 
 	} else if (matches(*argv, "ingress") == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"mirred ingress not supported at the moment\n");
+#endif
 	} else if (matches(*argv, "help") == 0) {
 		usage();
 	} else {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"mirred option not supported %s\n", *argv);
+#endif
 	}
 
 	return -1;
@@ -275,7 +301,9 @@ print_mirred(struct action_util *au,FILE
 
 
 	if ((dev = ll_index_to_name(p->ifindex)) == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Cannot find device %d\n", p->ifindex);
+#endif
 		return -1;
 	}
 
--- iproute2/tc/m_pedit.c
+++ iproute2/tc/m_pedit.c
@@ -32,6 +32,7 @@
 static struct m_pedit_util *pedit_list;
 int pedit_debug = 1;
 
+#ifdef NO_OPTSIZE
 static void
 explain(void)
 {
@@ -50,6 +51,9 @@ explain(void)
 		"For Example usage look at the examples directory\n");
 
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 static void
 usage(void)
@@ -62,10 +66,14 @@ static int
 pedit_parse_nopopt (int *argc_p, char ***argv_p,struct tc_pedit_sel *sel,struct tc_pedit_key *tkey)
 {
 	int argc = *argc_p;
+#ifdef NO_OPTSIZE
 	char **argv = *argv_p;
+#endif
 
 	if (argc) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Unknown action  hence option \"%s\" is unparsable\n", *argv);
+#endif
 			return -1;
 	}
 
@@ -127,7 +135,9 @@ pack_key(struct tc_pedit_sel *sel,struct
 		return -1;
 
 	if (tkey->off % 4) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "offsets MUST be in 32 bit boundaries\n");
+#endif
 		return -1;
 	}
 
@@ -146,8 +156,10 @@ int
 pack_key32(__u32 retain,struct tc_pedit_sel *sel,struct tc_pedit_key *tkey)
 {
 	if (tkey->off > (tkey->off & ~3)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,
 			"pack_key32: 32 bit offsets must begin in 32bit boundaries\n");
+#endif
 		return -1;
 	}
 
@@ -173,14 +185,18 @@ pack_key16(__u32 retain,struct tc_pedit_
 	}
 
 	if (tkey->val > 0xFFFF || tkey->mask > 0xFFFF) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "pack_key16 bad value\n");
+#endif
 		return -1;
 	}
 
 	ind = tkey->off & 3;
 
 	if (0 > ind || 2 < ind) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "pack_key16 bad index value %d\n",ind);
+#endif
 		return -1;
 	}
 
@@ -216,7 +232,9 @@ pack_key8(__u32 retain,struct tc_pedit_s
 	}
 
 	if (tkey->val > 0xFF || tkey->mask > 0xFF) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "pack_key8 bad value (val %x mask %x\n", tkey->val, tkey->mask);
+#endif
 		return -1;
 	}
 
@@ -440,7 +458,9 @@ parse_munge(int *argc_p, char ***argv_p,
 				goto bad_val;
 			res = p->parse_peopt(&argc, &argv, sel,&tkey);
 			if (res < 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr,"bad pedit parsing\n");
+#endif
 				goto bad_val;
 			}
 			goto done;
@@ -473,8 +493,10 @@ parse_pedit(struct action_util *a, int *
 	memset(&sel, 0, sizeof(sel));
 
 	while (argc > 0) {
+#ifdef NO_OPTSIZE
 		if (pedit_debug > 1)
 			fprintf(stderr, "while pedit (%d:%s)\n",argc, *argv);
+#endif
 		if (matches(*argv, "pedit") == 0) {
 			NEXT_ARG();
 			ok++;
@@ -483,13 +505,17 @@ parse_pedit(struct action_util *a, int *
 			usage();
 		} else if (matches(*argv, "munge") == 0) {
 			if (!ok) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal pedit construct (%s) \n", *argv);
+#endif
 				explain();
 				return -1;
 			}
 			NEXT_ARG();
 			if (parse_munge(&argc, &argv,&sel.sel)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal pedit construct (%s) \n", *argv);
+#endif
 				explain();
 				return -1;
 			}
@@ -529,7 +555,9 @@ parse_pedit(struct action_util *a, int *
 		if (matches(*argv, "index") == 0) {
 			NEXT_ARG();
 			if (get_u32(&sel.sel.index, *argv, 10)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Pedit: Illegal \"index\"\n");
+#endif
 				return -1;
 			}
 			argc--;
--- iproute2/tc/m_police.c
+++ iproute2/tc/m_police.c
@@ -32,6 +32,7 @@ struct action_util police_action_util =
 	.print_aopt = print_police,
 };
 
+#ifdef NO_OPTSIZE
 static void usage(void)
 {
 	fprintf(stderr, "Usage: ... police rate BPS burst BYTES[/BYTES] [ mtu BYTES[/BYTES] ]\n");
@@ -48,6 +49,10 @@ static void explain1(char *arg)
 {
 	fprintf(stderr, "Illegal \"%s\"\n", arg);
 }
+#else
+#define usage() exit(-1)
+#define explain1(a)
+#endif /* NO_OPTSIZE */
 
 char *police_action_n2a(int action, char *buf, int len)
 {
@@ -150,7 +155,9 @@ int act_parse_police(struct action_util
 		if (matches(*argv, "index") == 0) {
 			NEXT_ARG();
 			if (get_u32(&p.index, *argv, 10)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"index\"\n");
+#endif
 				return -1;
 			}
 		} else if (matches(*argv, "burst") == 0 ||
@@ -158,7 +165,9 @@ int act_parse_police(struct action_util
 			strcmp(*argv, "maxburst") == 0) {
 			NEXT_ARG();
 			if (buffer) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"buffer/burst\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_size_and_cell(&buffer, &Rcell_log, *argv) < 0) {
@@ -169,7 +178,9 @@ int act_parse_police(struct action_util
 			   strcmp(*argv, "minburst") == 0) {
 			NEXT_ARG();
 			if (mtu) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"mtu/minburst\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_size_and_cell(&mtu, &Pcell_log, *argv) < 0) {
@@ -179,7 +190,9 @@ int act_parse_police(struct action_util
 		} else if (strcmp(*argv, "mpu") == 0) {
 			NEXT_ARG();
 			if (mpu) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"mpu\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_size(&mpu, *argv)) {
@@ -189,7 +202,9 @@ int act_parse_police(struct action_util
 		} else if (strcmp(*argv, "rate") == 0) {
 			NEXT_ARG();
 			if (p.rate.rate) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"rate\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_rate(&p.rate.rate, *argv)) {
@@ -199,7 +214,9 @@ int act_parse_police(struct action_util
 		} else if (strcmp(*argv, "avrate") == 0) {
 			NEXT_ARG();
 			if (avrate) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"avrate\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_rate(&avrate, *argv)) {
@@ -209,7 +226,9 @@ int act_parse_police(struct action_util
 		} else if (matches(*argv, "peakrate") == 0) {
 			NEXT_ARG();
 			if (p.peakrate.rate) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"peakrate\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_rate(&p.peakrate.rate, *argv)) {
@@ -230,7 +249,9 @@ int act_parse_police(struct action_util
 		} else if (strcmp(*argv, "conform-exceed") == 0) {
 			NEXT_ARG();
 			if (get_police_result(&p.action, &presult, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"action\"\n");
+#endif
 				return -1;
 			}
 		} else if (strcmp(*argv, "help") == 0) {
@@ -246,23 +267,31 @@ int act_parse_police(struct action_util
 		return -1;
 
 	if (p.rate.rate && !buffer) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "\"burst\" requires \"rate\".\n");
+#endif
 		return -1;
 	}
 	if (p.peakrate.rate) {
 		if (!p.rate.rate) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "\"peakrate\" requires \"rate\".\n");
+#endif
 			return -1;
 		}
 		if (!mtu) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "\"mtu\" is required, if \"peakrate\" is requested.\n");
+#endif
 			return -1;
 		}
 	}
 
 	if (p.rate.rate) {
 		if ((Rcell_log = tc_calc_rtable(p.rate.rate, rtab, Rcell_log, mtu, mpu)) < 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "TBF: failed to calculate rate table.\n");
+#endif
 			return -1;
 		}
 		p.burst = tc_calc_xmittime(p.rate.rate, buffer);
@@ -272,7 +301,9 @@ int act_parse_police(struct action_util
 	p.mtu = mtu;
 	if (p.peakrate.rate) {
 		if ((Pcell_log = tc_calc_rtable(p.peakrate.rate, ptab, Pcell_log, mtu, mpu)) < 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "POLICE: failed to calculate peak rate table.\n");
+#endif
 			return -1;
 		}
 		p.peakrate.cell_log = Pcell_log;
--- iproute2/tc/q_atm.c
+++ iproute2/tc/q_atm.c
@@ -32,13 +32,16 @@
 static int atm_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
 {
 	if (argc) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr,"Usage: atm\n");
+#endif
 		return -1;
 	}
 	return 0;
 }
 
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... atm ( pvc ADDR | svc ADDR [ sap SAP ] ) "
@@ -46,6 +49,9 @@ static void explain(void)
 	fprintf(stderr, "  [ hdr HEX... ] [ excess ( CLASSID | clp ) ] "
 	  "[ clip ]\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 
 static int atm_parse_class_opt(struct qdisc_util *qu, int argc, char **argv,
@@ -117,7 +123,9 @@ static int atm_parse_class_opt(struct qd
 				int tmp;
 
 				if (ptr == hdr+MAX_HDR_LEN) {
+#ifdef NO_OPTSIZE
 					fprintf(stderr,"header is too long\n");
+#endif
 					return -1;
 				}
 				if (*walk == '.') continue;
@@ -152,31 +160,43 @@ static int atm_parse_class_opt(struct qd
 	}
 	s = socket(addr.sas_family,SOCK_DGRAM,0);
 	if (s < 0) {
+#ifdef NO_OPTSIZE
 		perror("socket");
+#endif
 		return -1;
 	}
 	if (setsockopt(s,SOL_ATM,SO_ATMQOS,&qos,sizeof(qos)) < 0) {
+#ifdef NO_OPTSIZE
 		perror("SO_ATMQOS");
+#endif
 		return -1;
 	}
 	if (sndbuf)
 	    if (setsockopt(s,SOL_SOCKET,SO_SNDBUF,&sndbuf,sizeof(sndbuf)) < 0) {
+#ifdef NO_OPTSIZE
 		perror("SO_SNDBUF");
+#endif
 	    return -1;
 	}
 	if (addr.sas_family == AF_ATMSVC && setsockopt(s,SOL_ATM,SO_ATMSAP,
 	    &sap,sizeof(sap)) < 0) {
+#ifdef NO_OPTSIZE
 		perror("SO_ATMSAP");
+#endif
 		return -1;
 	}
 	if (connect(s,(struct sockaddr *) &addr,addr.sas_family == AF_ATMPVC ?
 	    sizeof(struct sockaddr_atmpvc) : sizeof(addr)) < 0) {
+#ifdef NO_OPTSIZE
 		perror("connect");
+#endif
 		return -1;
 	}
 	if (set_clip)
 		if (ioctl(s,ATMARP_MKIP,0) < 0) {
+#ifdef NO_OPTSIZE
 			perror("ioctl ATMARP_MKIP");
+#endif
 			return -1;
 		}
 	tail = NLMSG_TAIL(n);
@@ -201,12 +221,18 @@ static int atm_print_opt(struct qdisc_ut
 	parse_rtattr_nested(tb, TCA_ATM_MAX, opt);
 	if (tb[TCA_ATM_ADDR]) {
 		if (RTA_PAYLOAD(tb[TCA_ATM_ADDR]) <
-		    sizeof(struct sockaddr_atmpvc))
+		    sizeof(struct sockaddr_atmpvc)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr,"ATM: address too short\n");
-		else {
+#endif
+		} else {
+#ifdef NO_OPTSIZE
 			if (atm2text(buffer,MAX_ATM_ADDR_LEN,
 			    RTA_DATA(tb[TCA_ATM_ADDR]),A2T_PRETTY | A2T_NAME) <
 			    0) fprintf(stderr,"atm2text error\n");
+#else
+			atm2text(buffer,MAX_ATM_ADDR_LEN,RTA_DATA(tb[TCA_ATM_ADDR]),A2T_PRETTY | A2T_NAME);
+#endif
 			fprintf(f,"pvc %s ",buffer);
 		}
 	}
@@ -223,9 +249,11 @@ static int atm_print_opt(struct qdisc_ut
 	if (tb[TCA_ATM_EXCESS]) {
 		__u32 excess;
 
-		if (RTA_PAYLOAD(tb[TCA_ATM_EXCESS]) < sizeof(excess))
+		if (RTA_PAYLOAD(tb[TCA_ATM_EXCESS]) < sizeof(excess)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr,"ATM: excess class ID too short\n");
-		else {
+#endif
+		} else {
 			excess = *(__u32 *) RTA_DATA(tb[TCA_ATM_EXCESS]);
 			if (!excess) fprintf(f,"excess clp ");
 			else {
@@ -240,9 +268,11 @@ static int atm_print_opt(struct qdisc_ut
 		static const char *map[] = { ATM_VS2TXT_MAP };
 		int state;
 
-		if (RTA_PAYLOAD(tb[TCA_ATM_STATE]) < sizeof(state))
+		if (RTA_PAYLOAD(tb[TCA_ATM_STATE]) < sizeof(state)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr,"ATM: state field too short\n");
-		else {
+#endif
+		} else {
 			state = *(int *) RTA_DATA(tb[TCA_ATM_STATE]);
 			fprintf(f,"%s ",map[state]);
 		}
--- iproute2/tc/q_cbq.c
+++ iproute2/tc/q_cbq.c
@@ -24,6 +24,7 @@
 #include "tc_util.h"
 #include "tc_cbq.h"
 
+#ifdef NO_OPTSIZE
 static void explain_class(void)
 {
 	fprintf(stderr, "Usage: ... cbq bandwidth BPS rate BPS maxburst PKTS [ avpkt BYTES ]\n");
@@ -44,6 +45,11 @@ static void explain1(char *arg)
 {
 	fprintf(stderr, "Illegal \"%s\"\n", arg);
 }
+#else
+#define explain_class()
+#define explain()
+#define explain1(a)
+#endif /* NO_OPTSIZE */
 
 #define usage() return(-1)
 
@@ -75,7 +81,9 @@ static int cbq_parse_opt(struct qdisc_ut
 				return -1;
 			}
 			if (ewma_log > 31) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "ewma_log must be < 32\n");
+#endif
 				return -1;
 			}
 		} else if (strcmp(*argv, "cell") == 0) {
@@ -90,7 +98,9 @@ static int cbq_parse_opt(struct qdisc_ut
 				if ((1<<i) == cell)
 					break;
 			if (i>=32) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "cell must be 2^n\n");
+#endif
 				return -1;
 			}
 			cell_log = i;
@@ -117,7 +127,9 @@ static int cbq_parse_opt(struct qdisc_ut
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
@@ -127,18 +139,24 @@ static int cbq_parse_opt(struct qdisc_ut
 	/* OK. All options are parsed. */
 
 	if (r.rate == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "CBQ: bandwidth is required parameter.\n");
+#endif
 		return -1;
 	}
 	if (avpkt == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "CBQ: \"avpkt\" is required.\n");
+#endif
 		return -1;
 	}
 	if (allot < (avpkt*3)/2)
 		allot = (avpkt*3)/2;
 
 	if ((cell_log = tc_calc_rtable(r.rate, rtab, cell_log, allot, mpu)) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "CBQ: failed to calculate rate table.\n");
+#endif
 		return -1;
 	}
 	r.cell_log = cell_log;
@@ -241,7 +259,9 @@ static int cbq_parse_class_opt(struct qd
 				return -1;
 			}
 			if (ewma_log > 31) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "ewma_log must be < 32\n");
+#endif
 				return -1;
 			}
 			lss.change |= TCF_CBQ_LSS_EWMA;
@@ -257,7 +277,9 @@ static int cbq_parse_class_opt(struct qd
 				if ((1<<i) == cell)
 					break;
 			if (i>=32) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "cell must be 2^n\n");
+#endif
 				return -1;
 			}
 			cell_log = i;
@@ -269,7 +291,9 @@ static int cbq_parse_class_opt(struct qd
 				return -1;
 			}
 			if (prio > TC_CBQ_MAXPRIO) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "\"prio\" must be number in the range 1...%d\n", TC_CBQ_MAXPRIO);
+#endif
 				return -1;
 			}
 			wrr.priority = prio;
@@ -303,7 +327,9 @@ static int cbq_parse_class_opt(struct qd
 		} else if (strcmp(*argv, "split") == 0) {
 			NEXT_ARG();
 			if (get_tc_classid(&fopt.split, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Invalid split node ID.\n");
+#endif
 				usage();
 			}
 			fopt_ok++;
@@ -312,7 +338,9 @@ static int cbq_parse_class_opt(struct qd
 			NEXT_ARG();
 			err = sscanf(*argv, "%08x/%08x", &fopt.defmap, &fopt.defchange);
 			if (err < 1) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Invalid defmap, should be MASK32[/MASK]\n");
+#endif
 				return -1;
 			}
 			if (err == 1)
@@ -322,7 +350,9 @@ static int cbq_parse_class_opt(struct qd
 			explain_class();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain_class();
 			return -1;
 		}
@@ -337,7 +367,9 @@ static int cbq_parse_class_opt(struct qd
 		if (wrr.allot < (lss.avpkt*3)/2)
 			wrr.allot = (lss.avpkt*3)/2;
 		if ((cell_log = tc_calc_rtable(r.rate, rtab, cell_log, pktsize, mpu)) < 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "CBQ: failed to calculate rate table.\n");
+#endif
 			return -1;
 		}
 		r.cell_log = cell_log;
@@ -348,11 +380,15 @@ static int cbq_parse_class_opt(struct qd
 	lss.ewma_log = ewma_log;
 	if (lss.change&(TCF_CBQ_LSS_OFFTIME|TCF_CBQ_LSS_MAXIDLE)) {
 		if (lss.avpkt == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "CBQ: avpkt is required for max/minburst.\n");
+#endif
 			return -1;
 		}
 		if (bndw==0 || r.rate == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "CBQ: bandwidth&rate are required for max/minburst.\n");
+#endif
 			return -1;
 		}
 	}
@@ -366,7 +402,9 @@ static int cbq_parse_class_opt(struct qd
 		if (wrr.weight == 0)
 			wrr.weight = (wrr.priority == TC_CBQ_MAXPRIO) ? 1 : r.rate;
 		if (wrr.allot == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "CBQ: \"allot\" is required to set WRR parameters.\n");
+#endif
 			return -1;
 		}
 	}
@@ -426,35 +464,45 @@ static int cbq_print_opt(struct qdisc_ut
 	parse_rtattr_nested(tb, TCA_CBQ_MAX, opt);
 
 	if (tb[TCA_CBQ_RATE]) {
-		if (RTA_PAYLOAD(tb[TCA_CBQ_RATE]) < sizeof(*r))
+		if (RTA_PAYLOAD(tb[TCA_CBQ_RATE]) < sizeof(*r)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "CBQ: too short rate opt\n");
-		else
+#endif
+		} else
 			r = RTA_DATA(tb[TCA_CBQ_RATE]);
 	}
 	if (tb[TCA_CBQ_LSSOPT]) {
-		if (RTA_PAYLOAD(tb[TCA_CBQ_LSSOPT]) < sizeof(*lss))
+		if (RTA_PAYLOAD(tb[TCA_CBQ_LSSOPT]) < sizeof(*lss)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "CBQ: too short lss opt\n");
-		else
+#endif
+		} else
 			lss = RTA_DATA(tb[TCA_CBQ_LSSOPT]);
 	}
 	if (tb[TCA_CBQ_WRROPT]) {
-		if (RTA_PAYLOAD(tb[TCA_CBQ_WRROPT]) < sizeof(*wrr))
+		if (RTA_PAYLOAD(tb[TCA_CBQ_WRROPT]) < sizeof(*wrr)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "CBQ: too short wrr opt\n");
-		else
+#endif
+		} else
 			wrr = RTA_DATA(tb[TCA_CBQ_WRROPT]);
 	}
 	if (tb[TCA_CBQ_FOPT]) {
-		if (RTA_PAYLOAD(tb[TCA_CBQ_FOPT]) < sizeof(*fopt))
+		if (RTA_PAYLOAD(tb[TCA_CBQ_FOPT]) < sizeof(*fopt)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "CBQ: too short fopt\n");
-		else
+#endif
+		} else
 			fopt = RTA_DATA(tb[TCA_CBQ_FOPT]);
 	}
 	if (tb[TCA_CBQ_OVL_STRATEGY]) {
-		if (RTA_PAYLOAD(tb[TCA_CBQ_OVL_STRATEGY]) < sizeof(*ovl))
+		if (RTA_PAYLOAD(tb[TCA_CBQ_OVL_STRATEGY]) < sizeof(*ovl)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "CBQ: too short overlimit strategy %u/%u\n",
 				(unsigned) RTA_PAYLOAD(tb[TCA_CBQ_OVL_STRATEGY]),
 				(unsigned) sizeof(*ovl));
-		else
+#endif
+		} else
 			ovl = RTA_DATA(tb[TCA_CBQ_OVL_STRATEGY]);
 	}
 
--- iproute2/tc/q_dsmark.c
+++ iproute2/tc/q_dsmark.c
@@ -22,11 +22,15 @@
 #define usage() return(-1)
 
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr,"Usage: dsmark indices INDICES [ default_index "
 	    "DEFAULT_INDEX ] [ set_tc_index ]\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 
 static int dsmark_parse_opt(struct qdisc_util *qu, int argc, char **argv,
@@ -87,7 +91,9 @@ static int dsmark_parse_opt(struct qdisc
 
 static void explain_class(void)
 {
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Usage: ... dsmark [ mask MASK ] [ value VALUE ]\n");
+#endif
 }
 
 
@@ -140,27 +146,47 @@ static int dsmark_print_opt(struct qdisc
 	memset(tb, 0, sizeof(tb));
 	parse_rtattr(tb, TCA_DSMARK_MAX, RTA_DATA(opt), RTA_PAYLOAD(opt));
 	if (tb[TCA_DSMARK_MASK]) {
+#ifdef NO_OPTSIZE
 		if (!RTA_PAYLOAD(tb[TCA_DSMARK_MASK]))
 			fprintf(stderr,"dsmark: empty mask\n");
 		else fprintf(f,"mask 0x%02x ",
+#else
+		if (RTA_PAYLOAD(tb[TCA_DSMARK_MASK]))
+			fprintf(f,"mask 0x%02x ",
+#endif
 			    *(__u8 *) RTA_DATA(tb[TCA_DSMARK_MASK]));
 	}
 	if (tb[TCA_DSMARK_VALUE]) {
+#ifdef NO_OPTSIZE
 		if (!RTA_PAYLOAD(tb[TCA_DSMARK_VALUE]))
 			fprintf(stderr,"dsmark: empty value\n");
 		else fprintf(f,"value 0x%02x ",
+#else
+		if (RTA_PAYLOAD(tb[TCA_DSMARK_VALUE]))
+			fprintf(f,"value 0x%02x ",
+#endif
 			    *(__u8 *) RTA_DATA(tb[TCA_DSMARK_VALUE]));
 	}
 	if (tb[TCA_DSMARK_INDICES]) {
+#ifdef NO_OPTSIZE
 		if (RTA_PAYLOAD(tb[TCA_DSMARK_INDICES]) < sizeof(__u16))
 			fprintf(stderr,"dsmark: indices too short\n");
 		else fprintf(f,"indices 0x%04x ",
+#else
+		if (!RTA_PAYLOAD(tb[TCA_DSMARK_INDICES]) < sizeof(__u16))
+			fprintf(f,"indices 0x%04x ",
+#endif
 			    *(__u16 *) RTA_DATA(tb[TCA_DSMARK_INDICES]));
 	}
 	if (tb[TCA_DSMARK_DEFAULT_INDEX]) {
+#ifdef NO_OPTSIZE
 		if (RTA_PAYLOAD(tb[TCA_DSMARK_DEFAULT_INDEX]) < sizeof(__u16))
 			fprintf(stderr,"dsmark: default_index too short\n");
 		else fprintf(f,"default_index 0x%04x ",
+#else
+		if (!RTA_PAYLOAD(tb[TCA_DSMARK_DEFAULT_INDEX]) < sizeof(__u16))
+			fprintf(f,"default_index 0x%04x ",
+#endif
 			    *(__u16 *) RTA_DATA(tb[TCA_DSMARK_DEFAULT_INDEX]));
 	}
 	if (tb[TCA_DSMARK_SET_TC_INDEX]) fprintf(f,"set_tc_index ");
--- iproute2/tc/q_fifo.c
+++ iproute2/tc/q_fifo.c
@@ -23,10 +23,14 @@
 #include "utils.h"
 #include "tc_util.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... [p|b]fifo [ limit NUMBER ]\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 #define usage() return(-1)
 
@@ -40,7 +44,9 @@ static int fifo_parse_opt(struct qdisc_u
 		if (strcmp(*argv, "limit") == 0) {
 			NEXT_ARG();
 			if (get_size(&opt.limit, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"limit\"\n");
+#endif
 				return -1;
 			}
 			ok++;
@@ -48,7 +54,9 @@ static int fifo_parse_opt(struct qdisc_u
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
--- iproute2/tc/q_gred.c
+++ iproute2/tc/q_gred.c
@@ -34,6 +34,7 @@
 #define DPRINTF(format,args...)
 #endif
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... gred DP drop-probability limit BYTES "
@@ -45,6 +46,9 @@ static void explain(void)
 	fprintf(stderr," gred setup DPs <num of DPs> default <default DP> "
 	    "[grio]\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 #define usage() return(-1)
 
@@ -62,25 +66,31 @@ static int init_gred(struct qdisc_util *
 			DPRINTF(stderr,"init_gred: next_arg with %s\n",*argv);
 			opt.DPs=strtol(*argv, (char **)NULL, 10);
 			if (opt.DPs >MAX_DPs) { /* need a better error check */
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "DPs =%u \n",opt.DPs);
 				fprintf(stderr, "Illegal \"DPs\"\n");
 				fprintf(stderr, "GRED: only %d DPs are "
 				    "currently supported\n",MAX_DPs);
+#endif
 				return -1;
 			}
 		} else if (strcmp(*argv, "default") == 0) {
 			NEXT_ARG();
 			opt.def_DP=strtol(*argv, (char **)NULL, 10);
 			if (!opt.DPs) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "\"default DP\" must be "
 				    "defined after DPs\n");
+#endif
 				return -1;
 			}
 			if (opt.def_DP>opt.DPs) {
 /*
 				fprintf(stderr, "\"default DP\" must be less than %d\nNote: DP runs from 0 to %d for %d DPs\n",opt.DPs,opt.DPs-1,opt.DPs);
 */
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "\"default DP\" must be less than %d\n",opt.DPs);
+#endif
 				return -1;
 			}
 		} else if (strcmp(*argv, "grio") == 0) {
@@ -89,7 +99,9 @@ static int init_gred(struct qdisc_util *
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
@@ -98,7 +110,9 @@ static int init_gred(struct qdisc_util *
 
 if ((!opt.DPs) || (!opt.def_DP))
 {
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Illegal gred setup parameters \n");
+#endif
 			return -1;
 }
 DPRINTF("TC_GRED: sending DPs=%d default=%d\n",opt.DPs,opt.def_DP);
@@ -130,13 +144,17 @@ static int gred_parse_opt(struct qdisc_u
 		if (strcmp(*argv, "limit") == 0) {
 			NEXT_ARG();
 			if (get_size(&opt.limit, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"limit\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "setup") == 0) {
 			if (ok) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"setup\"\n");
+#endif
 				return -1;
 			}
 		return init_gred(qu,argc-1, argv+1,n);
@@ -144,14 +162,18 @@ static int gred_parse_opt(struct qdisc_u
 		} else if (strcmp(*argv, "min") == 0) {
 			NEXT_ARG();
 			if (get_size(&opt.qth_min, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"min\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "max") == 0) {
 			NEXT_ARG();
 			if (get_size(&opt.qth_max, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"max\"\n");
+#endif
 				return -1;
 			}
 			ok++;
@@ -160,30 +182,38 @@ static int gred_parse_opt(struct qdisc_u
 			opt.DP=strtol(*argv, (char **)NULL, 10);
 			DPRINTF ("\n ******* DP =%u\n",opt.DP);
 			if (opt.DP >MAX_DPs) { /* need a better error check */
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "DP =%u \n",opt.DP);
 				fprintf(stderr, "Illegal \"DP\"\n");
 				fprintf(stderr, "GRED: only %d DPs are currently supported\n",MAX_DPs);
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "burst") == 0) {
 			NEXT_ARG();
                         if (get_unsigned(&burst, *argv, 0)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"burst\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "avpkt") == 0) {
 			NEXT_ARG();
 			if (get_size(&avpkt, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"avpkt\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "probability") == 0) {
 			NEXT_ARG();
 			if (sscanf(*argv, "%lg", &probability) != 1) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"probability\"\n");
+#endif
 				return -1;
 			}
 			ok++;
@@ -195,7 +225,9 @@ static int gred_parse_opt(struct qdisc_u
 		} else if (strcmp(*argv, "bandwidth") == 0) {
 			NEXT_ARG();
 			if (get_rate(&rate, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"bandwidth\"\n");
+#endif
 				return -1;
 			}
 			ok++;
@@ -203,7 +235,9 @@ static int gred_parse_opt(struct qdisc_u
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
@@ -218,28 +252,38 @@ static int gred_parse_opt(struct qdisc_u
 
 	if (!opt.qth_min || !opt.qth_max || !burst || !opt.limit || !avpkt ||
 	    (opt.DP<0)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Required parameter (min, max, burst, limit, "
 		    "avpket, DP) is missing\n");
+#endif
 		return -1;
 	}
 
 	if ((wlog = tc_red_eval_ewma(opt.qth_min, burst, avpkt)) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "GRED: failed to calculate EWMA constant.\n");
+#endif
 		return -1;
 	}
+#ifdef NO_OPTSIZE
 	if (wlog >= 10)
 		fprintf(stderr, "GRED: WARNING. Burst %d seems to be to "
 		    "large.\n", burst);
+#endif
 	opt.Wlog = wlog;
 	if ((wlog = tc_red_eval_P(opt.qth_min, opt.qth_max, probability)) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "GRED: failed to calculate probability.\n");
+#endif
 		return -1;
 	}
 	opt.Plog = wlog;
 	if ((wlog = tc_red_eval_idle_damping(opt.Wlog, avpkt, rate, sbuf)) < 0)
 	    {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "GRED: failed to calculate idle damping "
 		    "table.\n");
+#endif
 		return -1;
 	}
 	opt.Scell_log = wlog;
--- iproute2/tc/q_hfsc.c
+++ iproute2/tc/q_hfsc.c
@@ -27,6 +27,7 @@
 static int hfsc_get_sc(int *, char ***, struct tc_service_curve *);
 
 
+#ifdef NO_OPTSIZE
 static void
 explain_qdisc(void)
 {
@@ -65,6 +66,11 @@ explain1(char *arg)
 {
 	fprintf(stderr, "HFSC: Illegal \"%s\"\n", arg);
 }
+#else
+#define explain_qdisc()
+#define explain_class()
+#define explain1(a)
+#endif /* NO_OPTSIZE */
 
 static int
 hfsc_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
@@ -77,7 +83,9 @@ hfsc_parse_opt(struct qdisc_util *qu, in
 		if (matches(*argv, "default") == 0) {
 			NEXT_ARG();
 			if (qopt.defcls != 0) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "HFSC: Double \"default\"\n");
+#endif
 				return -1;
 			}
 			if (get_u16(&qopt.defcls, *argv, 16) < 0) {
@@ -88,7 +96,9 @@ hfsc_parse_opt(struct qdisc_util *qu, in
 			explain_qdisc();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "HFSC: What is \"%s\" ?\n", *argv);
+#endif
 			explain_qdisc();
 			return -1;
 		}
@@ -186,7 +196,9 @@ hfsc_parse_class_opt(struct qdisc_util *
 			explain_class();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "HFSC: What is \"%s\" ?\n", *argv);
+#endif
 			explain_class();
 			return -1;
 		}
@@ -194,13 +206,17 @@ hfsc_parse_class_opt(struct qdisc_util *
 	}
 
 	if (!(rsc_ok || fsc_ok || usc_ok)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "HFSC: no parameters given\n");
+#endif
 		explain_class();
 		return -1;
 	}
 	if (usc_ok && !fsc_ok) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "HFSC: Upper-limit Service Curve without "
 		                "Link-Share Service Curve\n");
+#endif
 		explain_class();
 		return -1;
 	}
@@ -242,21 +258,27 @@ hfsc_print_class_opt(struct qdisc_util *
 	parse_rtattr_nested(tb, TCA_HFSC_MAX, opt);
 
 	if (tb[TCA_HFSC_RSC]) {
-		if (RTA_PAYLOAD(tb[TCA_HFSC_RSC]) < sizeof(*rsc))
+		if (RTA_PAYLOAD(tb[TCA_HFSC_RSC]) < sizeof(*rsc)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "HFSC: truncated realtime option\n");
-		else
+#endif
+		} else
 			rsc = RTA_DATA(tb[TCA_HFSC_RSC]);
 	}
 	if (tb[TCA_HFSC_FSC]) {
-		if (RTA_PAYLOAD(tb[TCA_HFSC_FSC]) < sizeof(*fsc))
+		if (RTA_PAYLOAD(tb[TCA_HFSC_FSC]) < sizeof(*fsc)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "HFSC: truncated linkshare option\n");
-		else
+#endif
+		} else
 			fsc = RTA_DATA(tb[TCA_HFSC_FSC]);
 	}
 	if (tb[TCA_HFSC_USC]) {
-		if (RTA_PAYLOAD(tb[TCA_HFSC_USC]) < sizeof(*usc))
+		if (RTA_PAYLOAD(tb[TCA_HFSC_USC]) < sizeof(*usc)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "HFSC: truncated upperlimit option\n");
-		else
+#endif
+		} else
 			usc = RTA_DATA(tb[TCA_HFSC_USC]);
 	}
 
@@ -363,7 +385,9 @@ hfsc_get_sc2(int *argcp, char ***argvp,
 		return -1;
 
 	if (umax != 0 && dmax == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "HFSC: umax given but dmax is zero.\n");
+#endif
 		return -1;
 	}
 
@@ -398,7 +422,9 @@ hfsc_get_sc(int *argcp, char ***argvp, s
 		return -1;
 
 	if (sc->m1 == 0 && sc->m2 == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "HFSC: Service Curve has two zero slopes\n");
+#endif
 		return -1;
 	}
 
--- iproute2/tc/q_htb.c
+++ iproute2/tc/q_htb.c
@@ -28,6 +28,7 @@
 #error "Different kernel and TC HTB versions"
 #endif
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... qdisc add ... htb [default N] [r2q N]\n"
@@ -56,6 +57,10 @@ static void explain1(char *arg)
     fprintf(stderr, "Illegal \"%s\"\n", arg);
     explain();
 }
+#else
+#define explain()
+#define explain1(a)
+#endif /* NO_OPTSIZE */
 
 
 #define usage() return(-1)
@@ -87,7 +92,9 @@ static int htb_parse_opt(struct qdisc_ut
 			opt.debug |= (*p-'0')<<(2*i);
 		    }
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
@@ -161,7 +168,9 @@ static int htb_parse_class_opt(struct qd
 		} else if (strcmp(*argv, "ceil") == 0) {
 			NEXT_ARG();
 			if (opt.ceil.rate) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"ceil\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_rate(&opt.ceil.rate, *argv)) {
@@ -172,7 +181,9 @@ static int htb_parse_class_opt(struct qd
 		} else if (strcmp(*argv, "rate") == 0) {
 			NEXT_ARG();
 			if (opt.rate.rate) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"rate\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_rate(&opt.rate.rate, *argv)) {
@@ -184,7 +195,9 @@ static int htb_parse_class_opt(struct qd
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
@@ -195,7 +208,9 @@ static int htb_parse_class_opt(struct qd
 		return 0;*/
 
 	if (opt.rate.rate == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "\"rate\" is required.\n");
+#endif
 		return -1;
 	}
 	/* if ceil params are missing, use the same as rate */
@@ -211,14 +226,18 @@ static int htb_parse_class_opt(struct qd
 	opt.ceil.mpu = mpu; opt.rate.mpu = mpu;
 
 	if ((cell_log = tc_calc_rtable(opt.rate.rate, rtab, cell_log, mtu, mpu)) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "htb: failed to calculate rate table.\n");
+#endif
 		return -1;
 	}
 	opt.buffer = tc_calc_xmittime(opt.rate.rate, buffer);
 	opt.rate.cell_log = cell_log;
 
 	if ((ccell_log = tc_calc_rtable(opt.ceil.rate, ctab, cell_log, mtu, mpu)) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "htb: failed to calculate ceil rate table.\n");
+#endif
 		return -1;
 	}
 	opt.cbuffer = tc_calc_xmittime(opt.ceil.rate, cbuffer);
--- iproute2/tc/q_ingress.c
+++ iproute2/tc/q_ingress.c
@@ -27,10 +27,14 @@
 #include "utils.h"
 #include "tc_util.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... ingress \n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 #define usage() return(-1)
 
@@ -44,7 +48,9 @@ static int ingress_parse_opt(struct qdis
 				NEXT_ARG();
 				argc--; argv++;
 			} else {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 				explain();
 				return -1;
 			}
--- iproute2/tc/q_netem.c
+++ iproute2/tc/q_netem.c
@@ -25,6 +25,7 @@
 #include "tc_util.h"
 #include "tc_common.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr,
@@ -41,6 +42,10 @@ static void explain1(const char *arg)
 {
 	fprintf(stderr, "Illegal \"%s\"\n", arg);
 }
+#else
+#define explain()
+#define explain1(a)
+#endif /* NO_OPTSIZE */
 
 #define usage() return(-1)
 
@@ -62,8 +67,10 @@ static int get_distribution(const char *
 
 	snprintf(name, sizeof(name), "%s/%s.dist", get_tc_lib(), type);
 	if ((f = fopen(name, "r")) == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "No distribution data for %s (%s: %s)\n",
 			type, name, strerror(errno));
+#endif
 		return -1;
 	}
 
@@ -79,8 +86,10 @@ static int get_distribution(const char *
 				break;
 
 			if (n >= MAXDIST) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "%s: too much data\n",
 					name);
+#endif
 				n = -1;
 				goto error;
 			}
@@ -112,7 +121,9 @@ static int get_ticks(__u32 *ticks, const
 		return -1;
 
 	if (tc_core_time2big(t)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Illegal %u time (too large)\n", t);
+#endif
 		return -1;
 	}
 
@@ -244,7 +255,9 @@ static int netem_parse_opt(struct qdisc_
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
@@ -255,18 +268,24 @@ static int netem_parse_opt(struct qdisc_
 
 	if (reorder.probability) {
 		if (opt.latency == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "reordering not possible without specifying some delay\n");
+#endif
 		}
 		if (opt.gap == 0)
 			opt.gap = 1;
 	} else if (opt.gap > 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "gap specified without reorder probability\n");
+#endif
 		explain();
 		return -1;
 	}
 
 	if (dist_data && (opt.latency == 0 || opt.jitter == 0)) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "distribution specified but no latency and jitter values\n");
+#endif
 		explain();
 		return -1;
 	}
@@ -308,7 +327,9 @@ static int netem_print_opt(struct qdisc_
 		return 0;
 
 	if (len < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "options size error\n");
+#endif
 		return -1;
 	}
 	memcpy(&qopt, RTA_DATA(opt), sizeof(qopt));
--- iproute2/tc/q_prio.c
+++ iproute2/tc/q_prio.c
@@ -27,10 +27,14 @@
 #include "utils.h"
 #include "tc_util.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... prio bands NUMBER priomap P1 P2...\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 #define usage() return(-1)
 
@@ -47,13 +51,17 @@ static int prio_parse_opt(struct qdisc_u
 				explain();
 			NEXT_ARG();
 			if (get_integer(&opt.bands, *argv, 10)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"bands\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "priomap") == 0) {
 			if (pmap_mode) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Error: duplicate priomap\n");
+#endif
 				return -1;
 			}
 			pmap_mode = 1;
@@ -63,20 +71,28 @@ static int prio_parse_opt(struct qdisc_u
 		} else {
 			unsigned band;
 			if (!pmap_mode) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 				explain();
 				return -1;
 			}
 			if (get_unsigned(&band, *argv, 10)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"priomap\" element\n");
+#endif
 				return -1;
 			}
 			if (band > opt.bands) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "\"priomap\" element is out of bands\n");
+#endif
 				return -1;
 			}
 			if (idx > TC_PRIO_MAX) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "\"priomap\" index > TC_PRIO_MAX=%u\n", TC_PRIO_MAX);
+#endif
 				return -1;
 			}
 			opt.priomap[idx++] = band;
--- iproute2/tc/q_red.c
+++ iproute2/tc/q_red.c
@@ -25,11 +25,16 @@
 
 #include "tc_red.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... red limit BYTES min BYTES max BYTES avpkt BYTES burst PACKETS\n");
 	fprintf(stderr, "               probability PROBABILITY bandwidth KBPS [ ecn ]\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
+
 
 #define usage() return(-1)
 
@@ -52,49 +57,63 @@ static int red_parse_opt(struct qdisc_ut
 		if (strcmp(*argv, "limit") == 0) {
 			NEXT_ARG();
 			if (get_size(&opt.limit, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"limit\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "min") == 0) {
 			NEXT_ARG();
 			if (get_size(&opt.qth_min, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"min\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "max") == 0) {
 			NEXT_ARG();
 			if (get_size(&opt.qth_max, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"max\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "burst") == 0) {
 			NEXT_ARG();
 			if (get_unsigned(&burst, *argv, 0)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"burst\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "avpkt") == 0) {
 			NEXT_ARG();
 			if (get_size(&avpkt, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"avpkt\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "probability") == 0) {
 			NEXT_ARG();
 			if (sscanf(*argv, "%lg", &probability) != 1) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"probability\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "bandwidth") == 0) {
 			NEXT_ARG();
 			if (get_rate(&rate, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"bandwidth\"\n");
+#endif
 				return -1;
 			}
 			ok++;
@@ -105,7 +124,9 @@ static int red_parse_opt(struct qdisc_ut
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
@@ -119,24 +140,35 @@ static int red_parse_opt(struct qdisc_ut
 		get_rate(&rate, "10Mbit");
 
 	if (!opt.qth_min || !opt.qth_max || !burst || !opt.limit || !avpkt) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Required parameter (min, max, burst, limit, avpket) is missing\n");
+#endif
 		return -1;
 	}
 
 	if ((wlog = tc_red_eval_ewma(opt.qth_min, burst, avpkt)) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "RED: failed to calculate EWMA constant.\n");
+#endif
 		return -1;
 	}
-	if (wlog >= 10)
+	if (wlog >= 10) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "RED: WARNING. Burst %d seems to be to large.\n", burst);
+#endif
+	}
 	opt.Wlog = wlog;
 	if ((wlog = tc_red_eval_P(opt.qth_min, opt.qth_max, probability)) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "RED: failed to calculate probability.\n");
+#endif
 		return -1;
 	}
 	opt.Plog = wlog;
 	if ((wlog = tc_red_eval_idle_damping(opt.Wlog, avpkt, rate, sbuf)) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "RED: failed to calculate idle damping table.\n");
+#endif
 		return -1;
 	}
 	opt.Scell_log = wlog;
@@ -144,7 +176,9 @@ static int red_parse_opt(struct qdisc_ut
 #ifdef TC_RED_ECN
 		opt.flags |= TC_RED_ECN;
 #else
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "RED: ECN support is missing in this binary.\n");
+#endif
 		return -1;
 #endif
 	}
--- iproute2/tc/q_sfq.c
+++ iproute2/tc/q_sfq.c
@@ -23,10 +23,14 @@
 #include "utils.h"
 #include "tc_util.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... sfq [ limit NUMBER ] [ perturb SECS ] [ quantum BYTES ]\n");
 }
+#else
+#define explain()
+#endif /* NO_OPTSIZE */
 
 #define usage() return(-1)
 
@@ -41,25 +45,33 @@ static int sfq_parse_opt(struct qdisc_ut
 		if (strcmp(*argv, "quantum") == 0) {
 			NEXT_ARG();
 			if (get_size(&opt.quantum, *argv)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"limit\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "perturb") == 0) {
 			NEXT_ARG();
 			if (get_integer(&opt.perturb_period, *argv, 0)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"perturb\"\n");
+#endif
 				return -1;
 			}
 			ok++;
 		} else if (strcmp(*argv, "limit") == 0) {
 			NEXT_ARG();
 			if (get_u32(&opt.limit, *argv, 0)) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"limit\"\n");
+#endif
 				return -1;
 			}
 			if (opt.limit < 2) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Illegal \"limit\", must be > 1\n");
+#endif
 				return -1;
 			}
 			ok++;
@@ -67,7 +79,9 @@ static int sfq_parse_opt(struct qdisc_ut
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
--- iproute2/tc/q_tbf.c
+++ iproute2/tc/q_tbf.c
@@ -23,6 +23,7 @@
 #include "utils.h"
 #include "tc_util.h"
 
+#ifdef NO_OPTSIZE
 static void explain(void)
 {
 	fprintf(stderr, "Usage: ... tbf limit BYTES burst BYTES[/BYTES] rate KBPS [ mtu BYTES[/BYTES] ]\n");
@@ -33,6 +34,10 @@ static void explain1(char *arg)
 {
 	fprintf(stderr, "Illegal \"%s\"\n", arg);
 }
+#else
+#define explain()
+#define explain1(a)
+#endif /* NO_OPTSIZE */
 
 
 #define usage() return(-1)
@@ -53,7 +58,9 @@ static int tbf_parse_opt(struct qdisc_ut
 		if (matches(*argv, "limit") == 0) {
 			NEXT_ARG();
 			if (opt.limit || latency) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"limit/latency\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_size(&opt.limit, *argv)) {
@@ -64,7 +71,9 @@ static int tbf_parse_opt(struct qdisc_ut
 		} else if (matches(*argv, "latency") == 0) {
 			NEXT_ARG();
 			if (opt.limit || latency) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"limit/latency\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_time(&latency, *argv)) {
@@ -77,7 +86,9 @@ static int tbf_parse_opt(struct qdisc_ut
 			strcmp(*argv, "maxburst") == 0) {
 			NEXT_ARG();
 			if (buffer) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"buffer/burst\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_size_and_cell(&buffer, &Rcell_log, *argv) < 0) {
@@ -89,7 +100,9 @@ static int tbf_parse_opt(struct qdisc_ut
 			   strcmp(*argv, "minburst") == 0) {
 			NEXT_ARG();
 			if (mtu) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"mtu/minburst\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_size_and_cell(&mtu, &Pcell_log, *argv) < 0) {
@@ -100,7 +113,9 @@ static int tbf_parse_opt(struct qdisc_ut
 		} else if (strcmp(*argv, "mpu") == 0) {
 			NEXT_ARG();
 			if (mpu) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"mpu\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_size(&mpu, *argv)) {
@@ -111,7 +126,9 @@ static int tbf_parse_opt(struct qdisc_ut
 		} else if (strcmp(*argv, "rate") == 0) {
 			NEXT_ARG();
 			if (opt.rate.rate) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"rate\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_rate(&opt.rate.rate, *argv)) {
@@ -122,7 +139,9 @@ static int tbf_parse_opt(struct qdisc_ut
 		} else if (matches(*argv, "peakrate") == 0) {
 			NEXT_ARG();
 			if (opt.peakrate.rate) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Double \"peakrate\" spec\n");
+#endif
 				return -1;
 			}
 			if (get_rate(&opt.peakrate.rate, *argv)) {
@@ -134,7 +153,9 @@ static int tbf_parse_opt(struct qdisc_ut
 			explain();
 			return -1;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"?\n", *argv);
+#endif
 			explain();
 			return -1;
 		}
@@ -145,18 +166,24 @@ static int tbf_parse_opt(struct qdisc_ut
 		return 0;
 
 	if (opt.rate.rate == 0 || !buffer) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Both \"rate\" and \"burst\" are required.\n");
+#endif
 		return -1;
 	}
 	if (opt.peakrate.rate) {
 		if (!mtu) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "\"mtu\" is required, if \"peakrate\" is requested.\n");
+#endif
 			return -1;
 		}
 	}
 
 	if (opt.limit == 0 && latency == 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Either \"limit\" or \"latency\" are required.\n");
+#endif
 		return -1;
 	}
 
@@ -171,7 +198,9 @@ static int tbf_parse_opt(struct qdisc_ut
 	}
 
 	if ((Rcell_log = tc_calc_rtable(opt.rate.rate, rtab, Rcell_log, mtu, mpu)) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "TBF: failed to calculate rate table.\n");
+#endif
 		return -1;
 	}
 	opt.buffer = tc_calc_xmittime(opt.rate.rate, buffer);
@@ -179,7 +208,9 @@ static int tbf_parse_opt(struct qdisc_ut
 	opt.rate.mpu = mpu;
 	if (opt.peakrate.rate) {
 		if ((Pcell_log = tc_calc_rtable(opt.peakrate.rate, ptab, Pcell_log, mtu, mpu)) < 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "TBF: failed to calculate peak rate table.\n");
+#endif
 			return -1;
 		}
 		opt.mtu = tc_calc_xmittime(opt.peakrate.rate, mtu);
--- iproute2/tc/tc.c
+++ iproute2/tc/tc.c
@@ -54,7 +54,9 @@ static int print_noqopt(struct qdisc_uti
 static int parse_noqopt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
 {
 	if (argc) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Unknown qdisc \"%s\", hence option \"%s\" is unparsable\n", qu->id, *argv);
+#endif
 		return -1;
 	}
 	return 0;
@@ -75,13 +77,17 @@ static int parse_nofopt(struct filter_ut
 	__u32 handle;
 
 	if (argc) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Unknown filter \"%s\", hence option \"%s\" is unparsable\n", qu->id, *argv);
+#endif
 		return -1;
 	}
 	if (fhandle) {
 		struct tcmsg *t = NLMSG_DATA(n);
 		if (get_u32(&handle, fhandle, 16)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Unparsable filter ID \"%s\"\n", fhandle);
+#endif
 			return -1;
 		}
 		t->tcm_handle = handle;
@@ -177,6 +183,7 @@ noexist:
 	return q;
 }
 
+#ifdef NO_OPTSIZE
 static void usage(void)
 {
 	fprintf(stderr, "Usage: tc [ OPTIONS ] OBJECT { COMMAND | help }\n"
@@ -184,6 +191,9 @@ static void usage(void)
 	                "where  OBJECT := { qdisc | class | filter | action | monitor }\n"
 	                "       OPTIONS := { -s[tatistics] | -d[etails] | -r[aw] | -b[atch] [file] }\n");
 }
+#else
+#define usage()
+#endif /* NO_OPTSIZE */
 
 static int do_cmd(int argc, char **argv)
 {
@@ -207,8 +217,10 @@ static int do_cmd(int argc, char **argv)
 		return 0;
 	}
 
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Object \"%s\" is unknown, try \"tc help\".\n",
 		*argv);
+#endif
 	return -1;
 }
 
@@ -220,8 +232,10 @@ static int batch(const char *name)
 
 	if (name && strcmp(name, "-") != 0) {
 		if (freopen(name, "r", stdin) == NULL) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Cannot open file \"%s\" for reading: %s=n",
 				name, strerror(errno));
+#endif
 			return -1;
 		}
 	}
@@ -229,7 +243,9 @@ static int batch(const char *name)
 	tc_core_init();
 
 	if (rtnl_open(&rth, 0) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Cannot open rtnetlink\n");
+#endif
 		return -1;
 	}
 
@@ -243,7 +259,9 @@ static int batch(const char *name)
 			continue;	/* blank line */
 
 		if (do_cmd(largc, largv)) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Command failed %s:%d\n", name, cmdlineno);
+#endif
 			ret = 1;
 			if (!force)
 				break;
@@ -289,7 +307,9 @@ int main(int argc, char **argv)
 				batchfile = argv[2];
 			argc--;	argv++;
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Option \"%s\" is unknown, try \"tc -help\".\n", argv[1]);
+#endif
 			return -1;
 		}
 		argc--;	argv++;
@@ -305,7 +325,9 @@ int main(int argc, char **argv)
 
 	tc_core_init();
 	if (rtnl_open(&rth, 0) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Cannot open rtnetlink\n");
+#endif
 		exit(1);
 	}
 
--- iproute2/tc/tc_class.c
+++ iproute2/tc/tc_class.c
@@ -25,6 +25,7 @@
 #include "tc_util.h"
 #include "tc_common.h"
 
+#ifdef NO_OPTSIZE
 static void usage(void);
 
 static void usage(void)
@@ -39,6 +40,9 @@ static void usage(void)
 	fprintf(stderr, "OPTIONS := ... try tc class add <desired QDISC_KIND> help\n");
 	return;
 }
+#else
+#define usage()
+#endif /* NO_OPTSIZE */
 
 int tc_class_modify(int cmd, unsigned flags, int argc, char **argv)
 {
@@ -77,11 +81,15 @@ int tc_class_modify(int cmd, unsigned fl
 				invarg(*argv, "invalid class ID");
 			req.t.tcm_handle = handle;
 		} else if (strcmp(*argv, "handle") == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Error: try \"classid\" instead of \"handle\"\n");
+#endif
 			return -1;
  		} else if (strcmp(*argv, "root") == 0) {
 			if (req.t.tcm_parent) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Error: \"root\" is duplicate parent ID.\n");
+#endif
 				return -1;
 			}
 			req.t.tcm_parent = TC_H_ROOT;
@@ -115,7 +123,9 @@ int tc_class_modify(int cmd, unsigned fl
 
 	if (q) {
 		if (q->parse_copt == NULL) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Error: Qdisc \"%s\" is classless.\n", k);
+#endif
 			return 1;
 		}
 		if (q->parse_copt(q, argc, argv, &req.n))
@@ -124,7 +134,9 @@ int tc_class_modify(int cmd, unsigned fl
 		if (argc) {
 			if (matches(*argv, "help") == 0)
 				usage();
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Garbage instead of arguments \"%s ...\". Try \"tc class help\".", *argv);
+#endif
 			return -1;
 		}
 	}
@@ -133,7 +145,9 @@ int tc_class_modify(int cmd, unsigned fl
 		ll_init_map(&rth);
 
 		if ((req.t.tcm_ifindex = ll_name_to_index(d)) == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Cannot find device \"%s\"\n", d);
+#endif
 			return 1;
 		}
 	}
@@ -158,12 +172,16 @@ int print_class(const struct sockaddr_nl
 	char abuf[256];
 
 	if (n->nlmsg_type != RTM_NEWTCLASS && n->nlmsg_type != RTM_DELTCLASS) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not a class\n");
+#endif
 		return 0;
 	}
 	len -= NLMSG_LENGTH(sizeof(*t));
 	if (len < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Wrong len %d\n", len);
+#endif
 		return -1;
 	}
 	if (filter_qdisc && TC_H_MAJ(t->tcm_handle^filter_qdisc))
@@ -173,7 +191,9 @@ int print_class(const struct sockaddr_nl
 	parse_rtattr(tb, TCA_MAX, TCA_RTA(t), len);
 
 	if (tb[TCA_KIND] == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "print_class: NULL kind\n");
+#endif
 		return -1;
 	}
 
@@ -251,7 +271,9 @@ int tc_class_list(int argc, char **argv)
 				invarg(*argv, "invalid qdisc ID");
 		} else if (strcmp(*argv, "root") == 0) {
 			if (t.tcm_parent) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Error: \"root\" is duplicate parent ID\n");
+#endif
 				return -1;
 			}
 			t.tcm_parent = TC_H_ROOT;
@@ -266,7 +288,9 @@ int tc_class_list(int argc, char **argv)
 		} else if (matches(*argv, "help") == 0) {
 			usage();
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"? Try \"tc class help\".\n", *argv);
+#endif
 			return -1;
 		}
 
@@ -277,19 +301,25 @@ int tc_class_list(int argc, char **argv)
 
 	if (d[0]) {
 		if ((t.tcm_ifindex = ll_name_to_index(d)) == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Cannot find device \"%s\"\n", d);
+#endif
 			return 1;
 		}
 		filter_ifindex = t.tcm_ifindex;
 	}
 
  	if (rtnl_dump_request(&rth, RTM_GETTCLASS, &t, sizeof(t)) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot send dump request");
+#endif
 		return 1;
 	}
 
  	if (rtnl_dump_filter(&rth, print_class, stdout, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Dump terminated\n");
+#endif
 		return 1;
 	}
 
@@ -319,6 +349,8 @@ int do_class(int argc, char **argv)
 		usage();
 		return 0;
 	}
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Command \"%s\" is unknown, try \"tc class help\".\n", *argv);
+#endif
 	return -1;
 }
--- iproute2/tc/tc_filter.c
+++ iproute2/tc/tc_filter.c
@@ -26,6 +26,7 @@
 #include "tc_util.h"
 #include "tc_common.h"
 
+#ifdef NO_OPTSIZE
 static void usage(void);
 
 static void usage(void)
@@ -43,6 +44,9 @@ static void usage(void)
 	fprintf(stderr, "OPTIONS := ... try tc filter add <desired FILTER_KIND> help\n");
 	return;
 }
+#else
+#define usage()
+#endif /* NO_OPTSIZE */
 
 
 int tc_filter_modify(int cmd, unsigned flags, int argc, char **argv)
@@ -79,7 +83,9 @@ int tc_filter_modify(int cmd, unsigned f
 			strncpy(d, *argv, sizeof(d)-1);
 		} else if (strcmp(*argv, "root") == 0) {
 			if (req.t.tcm_parent) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Error: \"root\" is duplicate parent ID\n");
+#endif
 				return -1;
 			}
 			req.t.tcm_parent = TC_H_ROOT;
@@ -137,14 +143,18 @@ int tc_filter_modify(int cmd, unsigned f
 			return 1;
 	} else {
 		if (fhandle) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Must specify filter type when using "
 				"\"handle\"\n");
+#endif
 			return -1;
 		}
 		if (argc) {
 			if (matches(*argv, "help") == 0)
 				usage();
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Garbage instead of arguments \"%s ...\". Try \"tc filter help\".\n", *argv);
+#endif
 			return -1;
 		}
 	}
@@ -156,13 +166,17 @@ int tc_filter_modify(int cmd, unsigned f
  		ll_init_map(&rth);
 
 		if ((req.t.tcm_ifindex = ll_name_to_index(d)) == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Cannot find device \"%s\"\n", d);
+#endif
 			return 1;
 		}
 	}
 
  	if (rtnl_talk(&rth, &req.n, 0, 0, NULL, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "We have an error talking to the kernel\n");
+#endif
 		return 2;
 	}
 
@@ -186,12 +200,16 @@ int print_filter(const struct sockaddr_n
 	char abuf[256];
 
 	if (n->nlmsg_type != RTM_NEWTFILTER && n->nlmsg_type != RTM_DELTFILTER) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not a filter\n");
+#endif
 		return 0;
 	}
 	len -= NLMSG_LENGTH(sizeof(*t));
 	if (len < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Wrong len %d\n", len);
+#endif
 		return -1;
 	}
 
@@ -199,7 +217,9 @@ int print_filter(const struct sockaddr_n
 	parse_rtattr(tb, TCA_MAX, TCA_RTA(t), len);
 
 	if (tb[TCA_KIND] == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "print_filter: NULL kind\n");
+#endif
 		return -1;
 	}
 
@@ -273,7 +293,9 @@ int tc_filter_list(int argc, char **argv
 			strncpy(d, *argv, sizeof(d)-1);
 		} else if (strcmp(*argv, "root") == 0) {
 			if (t.tcm_parent) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Error: \"root\" is duplicate parent ID\n");
+#endif
 				return -1;
 			}
 			filter_parent = t.tcm_parent = TC_H_ROOT;
@@ -310,7 +332,9 @@ int tc_filter_list(int argc, char **argv
 		} else if (matches(*argv, "help") == 0) {
 			usage();
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, " What is \"%s\"? Try \"tc filter help\"\n", *argv);
+#endif
 			return -1;
 		}
 
@@ -323,19 +347,25 @@ int tc_filter_list(int argc, char **argv
 
 	if (d[0]) {
 		if ((t.tcm_ifindex = ll_name_to_index(d)) == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Cannot find device \"%s\"\n", d);
+#endif
 			return 1;
 		}
 		filter_ifindex = t.tcm_ifindex;
 	}
 
  	if (rtnl_dump_request(&rth, RTM_GETTFILTER, &t, sizeof(t)) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot send dump request");
+#endif
 		return 1;
 	}
 
  	if (rtnl_dump_filter(&rth, print_filter, stdout, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Dump terminated\n");
+#endif
 		return 1;
 	}
 
@@ -365,7 +395,9 @@ int do_filter(int argc, char **argv)
 		usage();
 		return 0;
         }
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Command \"%s\" is unknown, try \"tc filter help\".\n", *argv);
+#endif
 	return -1;
 }
 
--- iproute2/tc/tc_monitor.c
+++ iproute2/tc/tc_monitor.c
@@ -30,7 +30,9 @@ static void usage(void) __attribute__((n
 
 static void usage(void)
 {
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Usage: tc monitor\n");
+#endif
 	exit(-1);
 }
 
@@ -78,7 +80,9 @@ int do_tcmonitor(int argc, char **argv)
 			if (matches(*argv, "help") == 0) {
 				usage();
 			} else {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Argument \"%s\" is unknown, try \"tc monitor help\".\n", *argv);
+#endif
 				exit(-1);
 			}
 		}
@@ -89,7 +93,9 @@ int do_tcmonitor(int argc, char **argv)
 		FILE *fp;
 		fp = fopen(file, "r");
 		if (fp == NULL) {
+#ifdef NO_OPTSIZE
 			perror("Cannot fopen");
+#endif
 			exit(-1);
 		}
 		return rtnl_from_file(fp, accept_tcmsg, (void*)stdout);
--- iproute2/tc/tc_qdisc.c
+++ iproute2/tc/tc_qdisc.c
@@ -25,6 +25,7 @@
 #include "tc_util.h"
 #include "tc_common.h"
 
+#ifdef NO_OPTSIZE
 static int usage(void);
 
 static int usage(void)
@@ -40,6 +41,9 @@ static int usage(void)
 	fprintf(stderr, "OPTIONS := ... try tc qdisc add <desired QDISC_KIND> help\n");
 	return -1;
 }
+#else
+#define usage() return(-1)
+#endif /* NO_OPTSIZE */
 
 int tc_qdisc_modify(int cmd, unsigned flags, int argc, char **argv)
 {
@@ -79,14 +83,18 @@ int tc_qdisc_modify(int cmd, unsigned fl
 			req.t.tcm_handle = handle;
 		} else if (strcmp(*argv, "root") == 0) {
 			if (req.t.tcm_parent) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Error: \"root\" is duplicate parent ID\n");
+#endif
 				return -1;
 			}
 			req.t.tcm_parent = TC_H_ROOT;
 #ifdef TC_H_INGRESS
 		} else if (strcmp(*argv, "ingress") == 0) {
 			if (req.t.tcm_parent) {
+#ifdef NO_OPTSIZE
 				fprintf(stderr, "Error: \"ingress\" is a duplicate parent ID\n");
+#endif
 				return -1;
 			}
 			req.t.tcm_parent = TC_H_INGRESS;
@@ -127,7 +135,9 @@ int tc_qdisc_modify(int cmd, unsigned fl
 
 	if (q) {
 		if (!q->parse_qopt) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "qdisc '%s' does not support option parsing\n", k);
+#endif
 			return -1;
 		}
 		if (q->parse_qopt(q, argc, argv, &req.n))
@@ -137,7 +147,9 @@ int tc_qdisc_modify(int cmd, unsigned fl
 			if (matches(*argv, "help") == 0)
 				usage();
 
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Garbage instead of arguments \"%s ...\". Try \"tc qdisc help\".\n", *argv);
+#endif
 			return -1;
 		}
 	}
@@ -148,7 +160,9 @@ int tc_qdisc_modify(int cmd, unsigned fl
  		ll_init_map(&rth);
 
 		if ((idx = ll_name_to_index(d)) == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Cannot find device \"%s\"\n", d);
+#endif
 			return 1;
 		}
 		req.t.tcm_ifindex = idx;
@@ -174,12 +188,16 @@ int print_qdisc(const struct sockaddr_nl
 	char abuf[256];
 
 	if (n->nlmsg_type != RTM_NEWQDISC && n->nlmsg_type != RTM_DELQDISC) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Not a qdisc\n");
+#endif
 		return 0;
 	}
 	len -= NLMSG_LENGTH(sizeof(*t));
 	if (len < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Wrong len %d\n", len);
+#endif
 		return -1;
 	}
 
@@ -190,7 +208,9 @@ int print_qdisc(const struct sockaddr_nl
 	parse_rtattr(tb, TCA_MAX, TCA_RTA(t), len);
 
 	if (tb[TCA_KIND] == NULL) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "print_qdisc: NULL kind\n");
+#endif
 		return -1;
 	}
 
@@ -257,7 +277,9 @@ int tc_qdisc_list(int argc, char **argv)
 #ifdef TC_H_INGRESS
                 } else if (strcmp(*argv, "ingress") == 0) {
                              if (t.tcm_parent) {
+#ifdef NO_OPTSIZE
                                      fprintf(stderr, "Duplicate parent ID\n");
+#endif
                                      usage();
                              }
                              t.tcm_parent = TC_H_INGRESS;
@@ -265,7 +287,9 @@ int tc_qdisc_list(int argc, char **argv)
 		} else if (matches(*argv, "help") == 0) {
 			usage();
 		} else {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "What is \"%s\"? Try \"tc qdisc help\".\n", *argv);
+#endif
 			return -1;
 		}
 
@@ -276,19 +300,25 @@ int tc_qdisc_list(int argc, char **argv)
 
 	if (d[0]) {
 		if ((t.tcm_ifindex = ll_name_to_index(d)) == 0) {
+#ifdef NO_OPTSIZE
 			fprintf(stderr, "Cannot find device \"%s\"\n", d);
+#endif
 			return 1;
 		}
 		filter_ifindex = t.tcm_ifindex;
 	}
 
  	if (rtnl_dump_request(&rth, RTM_GETQDISC, &t, sizeof(t)) < 0) {
+#ifdef NO_OPTSIZE
 		perror("Cannot send dump request");
+#endif
 		return 1;
 	}
 
  	if (rtnl_dump_filter(&rth, print_qdisc, stdout, NULL, NULL) < 0) {
+#ifdef NO_OPTSIZE
 		fprintf(stderr, "Dump terminated\n");
+#endif
 		return 1;
 	}
 
@@ -320,6 +350,8 @@ int do_qdisc(int argc, char **argv)
 		usage();
 		return 0;
         }
+#ifdef NO_OPTSIZE
 	fprintf(stderr, "Command \"%s\" is unknown, try \"tc qdisc help\".\n", *argv);
+#endif
 	return -1;
 }
