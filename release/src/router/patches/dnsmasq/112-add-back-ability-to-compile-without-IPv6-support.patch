--- dnsmasq/src/arp.c
+++ dnsmasq/src/arp.c
@@ -44,6 +44,11 @@
   if (maclen > DHCP_CHADDR_MAX)
     return 1;
 
+#ifndef HAVE_IPV6
+  if (family != AF_INET)
+    return 1;
+#endif
+
   /* Look for existing entry */
   for (arp = arps; arp; arp = arp->next)
     {
@@ -55,11 +60,13 @@
 	  if (arp->addr.addr4.s_addr != ((struct in_addr *)addrp)->s_addr)
 	    continue;
 	}
+#ifdef HAVE_IPV6
       else
 	{
 	  if (!IN6_ARE_ADDR_EQUAL(&arp->addr.addr6, (struct in6_addr *)addrp))
 	    continue;
 	}
+#endif
 
       if (arp->status == ARP_EMPTY)
 	{
@@ -96,8 +103,10 @@
       memcpy(arp->hwaddr, mac, maclen);
       if (family == AF_INET)
 	arp->addr.addr4.s_addr = ((struct in_addr *)addrp)->s_addr;
+#ifdef HAVE_IPV6
       else
 	memcpy(&arp->addr.addr6, addrp, IN6ADDRSZ);
+#endif
     }
   
   return 1;
@@ -127,9 +136,11 @@
 	      arp->addr.addr4.s_addr != addr->in.sin_addr.s_addr)
 	    continue;
 	    
+#ifdef HAVE_IPV6
 	  if (arp->family == AF_INET6 && 
 	      !IN6_ARE_ADDR_EQUAL(&arp->addr.addr6, &addr->in6.sin6_addr))
 	    continue;
+#endif
 	  
 	  /* Only accept positive entries unless in lazy mode. */
 	  if (arp->status != ARP_EMPTY || lazy || updated)
@@ -192,8 +203,10 @@
 
       if (addr->sa.sa_family == AF_INET)
 	arp->addr.addr4.s_addr = addr->in.sin_addr.s_addr;
+#ifdef HAVE_IPV6
       else
 	memcpy(&arp->addr.addr6, &addr->in6.sin6_addr, IN6ADDRSZ);
+#endif
     }
 	  
    return 0;
--- dnsmasq/src/auth.c
+++ dnsmasq/src/auth.c
@@ -33,8 +33,10 @@
 	if  (is_same_net(addr, list->addr.addr4, netmask))
 	  return list;
       }
+#ifdef HAVE_IPV6
     else if (is_same_net6(&(addr_u->addr6), &list->addr.addr6, list->prefixlen))
       return list;
+#endif
     
   } while ((list = list->next));
   
@@ -187,6 +189,7 @@
 		  while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
 		    intr = intr->next;
 	      }
+#ifdef HAVE_IPV6
 	  else if (flag == F_IPV6)
 	    for (intr = daemon->int_names; intr; intr = intr->next)
 	      {
@@ -202,6 +205,7 @@
 		  while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
 		    intr = intr->next;
 	      }
+#endif
 	  
 	  if (intr)
 	    {
@@ -374,8 +378,10 @@
        if (qtype == T_A)
 	 flag = F_IPV4;
        
+#ifdef HAVE_IPV6
        if (qtype == T_AAAA)
 	 flag = F_IPV6;
+#endif
        
        for (intr = daemon->int_names; intr; intr = intr->next)
 	 if ((rc = hostname_issubdomain(name, intr->name)))
@@ -389,9 +395,10 @@
 		 if (((addrlist->flags & ADDRLIST_IPV6)  ? T_AAAA : T_A) == qtype &&
 		     (local_query || filter_zone(zone, flag, &addrlist->addr)))
 		   {
+#ifdef HAVE_IPV6
 		     if (addrlist->flags & ADDRLIST_REVONLY)
 		       continue;
-
+#endif
 		     found = 1;
 		     log_query(F_FORWARD | F_CONFIG | flag, name, &addrlist->addr, NULL);
 		     if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
@@ -417,11 +424,13 @@
 	      
 	      if (peer_addr->sa.sa_family == AF_INET)
 		peer_addr->in.sin_port = 0;
+#ifdef HAVE_IPV6
 	      else
 		{
 		  peer_addr->in6.sin6_port = 0; 
 		  peer_addr->in6.sin6_scope_id = 0;
 		}
+#endif
 	      
 	      for (peers = daemon->auth_peers; peers; peers = peers->next)
 		if (sockaddr_isequal(peer_addr, &peers->addr))
@@ -433,8 +442,10 @@
 		{
 		  if (peer_addr->sa.sa_family == AF_INET)
 		    inet_ntop(AF_INET, &peer_addr->in.sin_addr, daemon->addrbuff, ADDRSTRLEN);
+#ifdef HAVE_IPV6
 		  else
 		    inet_ntop(AF_INET6, &peer_addr->in6.sin6_addr, daemon->addrbuff, ADDRSTRLEN); 
+#endif
 		  
 		  my_syslog(LOG_WARNING, _("ignoring zone transfer request from %s"), daemon->addrbuff);
 		  return 0;
@@ -592,6 +603,7 @@
 	      p += sprintf(p, "%u.in-addr.arpa", a & 0xff);
 	      
 	    }
+#ifdef HAVE_IPV6
 	  else
 	    {
 	      char *p = name;
@@ -605,6 +617,7 @@
 	      p += sprintf(p, "ip6.arpa");
 	      
 	    }
+#endif
 	}
       
       /* handle NS and SOA in auth section or for explicit queries */
@@ -745,12 +758,14 @@
 					  daemon->auth_ttl, NULL, T_A, C_IN, "4", cut ? intr->name : NULL, &addrlist->addr))
 		    anscount++;
 		
+#ifdef HAVE_IPV6
 		for (addrlist = intr->addr; addrlist; addrlist = addrlist->next) 
 		  if ((addrlist->flags & ADDRLIST_IPV6) && 
 		      (local_query || filter_zone(zone, F_IPV6, &addrlist->addr)) &&
 		      add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
 					  daemon->auth_ttl, NULL, T_AAAA, C_IN, "6", cut ? intr->name : NULL, &addrlist->addr))
 		    anscount++;
+#endif		    
 		
 		/* restore config data */
 		if (cut)
@@ -787,11 +802,18 @@
 		    {
 		      char *cache_name = cache_get_name(crecp);
 		      if (!strchr(cache_name, '.') && 
-			  (local_query || filter_zone(zone, (crecp->flags & (F_IPV6 | F_IPV4)), &(crecp->addr))) &&
-			  add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
-					      daemon->auth_ttl, NULL, (crecp->flags & F_IPV6) ? T_AAAA : T_A, C_IN, 
-					      (crecp->flags & F_IPV4) ? "4" : "6", cache_name, &crecp->addr))
-			anscount++;
+			  (local_query || filter_zone(zone, (crecp->flags & (F_IPV6 | F_IPV4)), &(crecp->addr))))
+			{
+			  qtype = T_A;
+#ifdef HAVE_IPV6
+			  if (crecp->flags & F_IPV6)
+			    qtype = T_AAAA;
+#endif
+			  if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
+						  daemon->auth_ttl, NULL, qtype, C_IN, 
+						  (crecp->flags & F_IPV4) ? "4" : "6", cache_name, &crecp->addr))
+			    anscount++;
+			}
 		    }
 		  
 		  if ((crecp->flags & F_HOSTS) || (((crecp->flags & F_DHCP) && option_bool(OPT_DHCP_FQDN))))
@@ -800,13 +822,18 @@
 		      if (in_zone(zone, name, &cut) && 
 			  (local_query || filter_zone(zone, (crecp->flags & (F_IPV6 | F_IPV4)), &(crecp->addr))))
 			{
-			  if (cut)
-			    *cut = 0;
+			  qtype = T_A;
+#ifdef HAVE_IPV6
+			  if (crecp->flags & F_IPV6)
+			    qtype = T_AAAA;
+#endif
+			   if (cut)
+			     *cut = 0;
 
-			  if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
-						  daemon->auth_ttl, NULL, (crecp->flags & F_IPV6) ? T_AAAA : T_A, C_IN, 
-						  (crecp->flags & F_IPV4) ? "4" : "6", cut ? name : NULL, &crecp->addr))
-			    anscount++;
+			   if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
+						   daemon->auth_ttl, NULL, qtype, C_IN, 
+						   (crecp->flags & F_IPV4) ? "4" : "6", cut ? name : NULL, &crecp->addr))
+			     anscount++;
 			}
 		    }
 		}
--- dnsmasq/src/bpf.c
+++ dnsmasq/src/bpf.c
@@ -31,7 +31,9 @@
 #  include <net/if_var.h> 
 #endif
 #include <netinet/in_var.h>
-#include <netinet6/in6_var.h>
+#ifdef HAVE_IPV6
+#  include <netinet6/in6_var.h>
+#endif
 
 #ifndef SA_SIZE
 #define SA_SIZE(sa)                                             \
@@ -119,7 +121,7 @@
   if (getifaddrs(&head) == -1)
     return 0;
 
-#if defined(HAVE_BSD_NETWORK)
+#if defined(HAVE_BSD_NETWORK) && defined(HAVE_IPV6)
   if (family == AF_INET6)
     fd = socket(PF_INET6, SOCK_DGRAM, 0);
 #endif
@@ -150,6 +152,7 @@
 	      if (!((*callback)(addr, iface_index, NULL, netmask, broadcast, parm)))
 		goto err;
 	    }
+#ifdef HAVE_IPV6
 	  else if (family == AF_INET6)
 	    {
 	      struct in6_addr *addr = &((struct sockaddr_in6 *) addrs->ifa_addr)->sin6_addr;
@@ -216,6 +219,7 @@
 				(int) preferred, (int)valid, parm)))
 		goto err;	      
 	    }
+#endif /* HAVE_IPV6 */
 
 #ifdef HAVE_DHCP6      
 	  else if (family == AF_LINK)
@@ -423,8 +427,10 @@
 		 del_family = sa->sa_family;
 		 if (del_family == AF_INET)
 		   del_addr.addr4 = ((struct sockaddr_in *)sa)->sin_addr;
+#ifdef HAVE_IPV6
 		 else if (del_family == AF_INET6)
 		   del_addr.addr6 = ((struct sockaddr_in6 *)sa)->sin6_addr;
+#endif
 		 else
 		   del_family = 0;
 	       }
--- dnsmasq/src/cache.c
+++ dnsmasq/src/cache.c
@@ -415,8 +415,11 @@
   else
     {
       int i;
+#ifdef HAVE_IPV6
       int addrlen = (flags & F_IPV6) ? IN6ADDRSZ : INADDRSZ;
-
+#else
+      int addrlen = INADDRSZ;
+#endif 
       for (i = 0; i < hash_size; i++)
 	for (crecp = hash_table[i], up = &hash_table[i]; 
 	     crecp && ((crecp->flags & F_REVERSE) || !(crecp->flags & F_IMMORTAL));
@@ -534,9 +537,11 @@
 	  if ((flags & F_IPV4) && (new->flags & F_IPV4) &&
 	      new->addr.addr4.s_addr == addr->addr4.s_addr)
 	    return new;
+#ifdef HAVE_IPV6
 	  else if ((flags & F_IPV6) && (new->flags & F_IPV6) &&
 		   IN6_ARE_ADDR_EQUAL(&new->addr.addr6, &addr->addr6))
 	    return new;
+#endif
 	}
 
       insert_error = 1;
@@ -910,7 +915,11 @@
 				time_t now, unsigned int prot)
 {
   struct crec *ans;
+#ifdef HAVE_IPV6
   int addrlen = (prot == F_IPV6) ? IN6ADDRSZ : INADDRSZ;
+#else
+  int addrlen = INADDRSZ;
+#endif
   
   if (crecp) /* iterating */
     ans = crecp->next;
@@ -1105,12 +1114,14 @@
 	  addrlen = INADDRSZ;
 	  domain_suffix = get_domain(addr.addr4);
 	}
+#ifdef HAVE_IPV6
       else if (inet_pton(AF_INET6, token, &addr) > 0)
 	{
 	  flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV6;
 	  addrlen = IN6ADDRSZ;
 	  domain_suffix = get_domain6(&addr.addr6);
 	}
+#endif
       else
 	{
 	  my_syslog(LOG_ERR, _("bad address at %s line %d"), filename, lineno); 
@@ -1279,7 +1290,7 @@
 	    cache->flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV4 | F_NAMEP | F_CONFIG;
 	    add_hosts_entry(cache, (union all_addr *)&hr->addr, INADDRSZ, SRC_CONFIG, (struct crec **)daemon->packet, revhashsz);
 	  }
-
+#ifdef HAVE_IPV6
 	if ((hr->flags & HR_6) &&
 	    (cache = whine_malloc(SIZEOF_POINTER_CREC)))
 	  {
@@ -1288,6 +1299,7 @@
 	    cache->flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV6 | F_NAMEP | F_CONFIG;
 	    add_hosts_entry(cache, (union all_addr *)&hr->addr6, IN6ADDRSZ, SRC_CONFIG, (struct crec **)daemon->packet, revhashsz);
 	  }
+#endif
       }
 	
   if (option_bool(OPT_NO_HOSTS) && !daemon->addn_hosts)
@@ -1386,11 +1398,13 @@
   int in_hosts = 0;
   size_t addrlen = sizeof(struct in_addr);
 
+#ifdef HAVE_IPV6
   if (prot == AF_INET6)
     {
       flags = F_IPV6;
       addrlen = sizeof(struct in6_addr);
     }
+#endif
   
   inet_ntop(prot, host_address, daemon->addrbuff, ADDRSTRLEN);
   
@@ -1751,8 +1765,10 @@
 		a = daemon->addrbuff;
 		if (cache->flags & F_IPV4)
 		  inet_ntop(AF_INET, &cache->addr, a, ADDRSTRLEN);
+#ifdef HAVE_IPV6
 		else if (cache->flags & F_IPV6)
 		  inet_ntop(AF_INET6, &cache->addr, a, ADDRSTRLEN);
+#endif
 	      }
 
 	    if (cache->flags & F_IPV4)
@@ -1895,9 +1911,14 @@
 	     sprintf(daemon->addrbuff, "%u", rcode);
 	}
       else
-	inet_ntop(flags & F_IPV4 ? AF_INET : AF_INET6,
-		  addr, daemon->addrbuff, ADDRSTRLEN);
-      
+	{
+#ifdef HAVE_IPV6
+	  inet_ntop(flags & F_IPV4 ? AF_INET : AF_INET6,
+		    addr, daemon->addrbuff, ADDRSTRLEN);
+#else
+	  strncpy(daemon->addrbuff, inet_ntoa(addr->addr4), ADDRSTRLEN);  
+#endif
+	}
     }
   else
     dest = arg;
--- dnsmasq/src/config.h
+++ dnsmasq/src/config.h
@@ -143,6 +143,7 @@
 
 NO_ID
    Don't report *.bind CHAOS info to clients, forward such requests upstream instead.
+NO_IPV6
 NO_TFTP
 NO_DHCP
 NO_DHCP6
@@ -152,8 +153,8 @@
 NO_DUMPFILE
 NO_INOTIFY
    these are available to explicitly disable compile time options which would 
-   otherwise be enabled automatically or which are enabled  by default 
-   in the distributed source tree. Building dnsmasq
+   otherwise be enabled automatically (HAVE_IPV6, >2Gb file sizes) or 
+   which are enabled  by default in the distributed source tree. Building dnsmasq
    with something like "make COPTS=-DNO_SCRIPT" will do the trick.
 NO_GMP
    Don't use and link against libgmp, Useful if nettle is built with --enable-mini-gmp.
@@ -315,9 +316,29 @@
  
 #endif
 
+/* Decide if we're going to support IPv6 */
+/* We assume that systems which don't have IPv6
+   headers don't have ntop and pton either */
+
+#if defined(INET6_ADDRSTRLEN) && defined(IPV6_V6ONLY)
+#  define HAVE_IPV6
+#  define ADDRSTRLEN INET6_ADDRSTRLEN
+#else
+#  if !defined(INET_ADDRSTRLEN)
+#      define INET_ADDRSTRLEN 16 /* 4*3 + 3 dots + NULL */
+#  endif
+#  undef HAVE_IPV6
+#  define ADDRSTRLEN INET_ADDRSTRLEN
+#endif
+
+
 /* rules to implement compile-time option dependencies and 
    the NO_XXX flags */
 
+#ifdef NO_IPV6
+#undef HAVE_IPV6
+#endif
+
 #ifdef NO_TFTP
 #undef HAVE_TFTP
 #endif
@@ -327,7 +348,7 @@
 #undef HAVE_DHCP6
 #endif
 
-#if defined(NO_DHCP6)
+#if defined(NO_DHCP6) || !defined(HAVE_IPV6)
 #undef HAVE_DHCP6
 #endif
 
@@ -376,6 +397,9 @@
 #ifdef DNSMASQ_COMPILE_OPTS
 
 static char *compile_opts = 
+#ifndef HAVE_IPV6
+"no-"
+#endif
 "IPv6 "
 #ifndef HAVE_GETOPT_LONG
 "no-"
--- dnsmasq/src/conntrack.c
+++ dnsmasq/src/conntrack.c
@@ -36,6 +36,7 @@
       nfct_set_attr_u8(ct, ATTR_L4PROTO, istcp ? IPPROTO_TCP : IPPROTO_UDP);
       nfct_set_attr_u16(ct, ATTR_PORT_DST, htons(daemon->port));
       
+#ifdef HAVE_IPV6
       if (peer_addr->sa.sa_family == AF_INET6)
 	{
 	  nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET6);
@@ -44,6 +45,7 @@
 	  nfct_set_attr(ct, ATTR_IPV6_DST, local_addr->addr6.s6_addr);
 	}
       else
+#endif
 	{
 	  nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET);
 	  nfct_set_attr_u32(ct, ATTR_IPV4_SRC, peer_addr->in.sin_addr.s_addr);
--- dnsmasq/src/dbus.c
+++ dnsmasq/src/dbus.c
@@ -185,6 +185,9 @@
 		}
 	    }
 
+#ifndef HAVE_IPV6
+	  my_syslog(LOG_WARNING, _("attempt to set an IPv6 server address via DBus - no IPv6 support"));
+#else
 	  if (i == sizeof(struct in6_addr))
 	    {
 	      memcpy(&addr.in6.sin6_addr, p, sizeof(struct in6_addr));
@@ -199,6 +202,7 @@
               source_addr.in6.sin6_port = htons(daemon->query_port);
 	      skip = 0;
 	    }
+#endif
 	}
       else
 	/* At the end */
--- dnsmasq/src/dnsmasq.c
+++ dnsmasq/src/dnsmasq.c
@@ -1878,11 +1878,11 @@
 		  indextoname(listener->tcpfd, if_index, intr_name))
 		{
 		  union all_addr addr;
-		  
+		  addr.addr4 = tcp_addr.in.sin_addr;
+#ifdef HAVE_IPV6
 		  if (tcp_addr.sa.sa_family == AF_INET6)
 		    addr.addr6 = tcp_addr.in6.sin6_addr;
-		  else
-		    addr.addr4 = tcp_addr.in.sin_addr;
+#endif
 		  
 		  for (iface = daemon->interfaces; iface; iface = iface->next)
 		    if (iface->index == if_index &&
--- dnsmasq/src/dnsmasq.h
+++ dnsmasq/src/dnsmasq.h
@@ -130,7 +130,9 @@
 #include <net/if_arp.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
+#ifdef HAVE_IPV6
 #include <netinet/ip6.h>
+#endif
 #include <netinet/ip_icmp.h>
 #include <netinet/tcp.h>
 #include <sys/uio.h>
@@ -164,8 +166,6 @@
 /* daemon is function in the C library.... */
 #define daemon dnsmasq_daemon
 
-#define ADDRSTRLEN INET6_ADDRSTRLEN
-
 /* Async event queue */
 struct event_desc {
   int event, data, msg_sz;
@@ -291,6 +291,8 @@
 union all_addr {
   struct in_addr addr4;
+#ifdef HAVE_IPV6
   struct in6_addr addr6;
+#endif
   struct {
     union {
       struct crec *cache;
@@ -419,7 +421,9 @@
     struct name_list *next;
   } *names;
   struct in_addr addr;
+#ifdef HAVE_IPV6
   struct in6_addr addr6;
+#endif
   struct host_record *next;
 };
 
@@ -503,7 +507,9 @@
 union mysockaddr {
   struct sockaddr sa;
   struct sockaddr_in in;
+#if defined(HAVE_IPV6)
   struct sockaddr_in6 in6;
+#endif
 };
 
 /* bits in flag param to IPv6 callbacks from iface_enumerate() */
@@ -670,7 +676,9 @@
   } frec_src;
   struct server *sentto; /* NULL means free */
   struct randfd *rfd4;
+#ifdef HAVE_IPV6
   struct randfd *rfd6;
+#endif
   unsigned short new_id;
   int forwardall, flags;
   time_t time;
@@ -894,7 +902,9 @@
 struct cond_domain {
   char *domain, *prefix;
   struct in_addr start, end;
+#ifdef HAVE_IPV6
   struct in6_addr start6, end6;
+#endif
   int is6, indexed;
   struct cond_domain *next;
 }; 
@@ -1209,7 +1219,9 @@
 
 /* domain.c */
 char *get_domain(struct in_addr addr);
+#ifdef HAVE_IPV6
 char *get_domain6(struct in6_addr *addr);
+#endif
 int is_name_synthetic(int flags, char *name, union all_addr *addr);
 int is_rev_synth(int flag, union all_addr *addr, char *name);
 
@@ -1296,9 +1308,11 @@
 time_t dnsmasq_time(void);
 int netmask_length(struct in_addr mask);
 int is_same_net(struct in_addr a, struct in_addr b, struct in_addr mask);
+#ifdef HAVE_IPV6
 int is_same_net6(struct in6_addr *a, struct in6_addr *b, int prefixlen);
 u64 addr6part(struct in6_addr *addr);
 void setaddr6part(struct in6_addr *addr, u64 host);
+#endif
 int retry_send(ssize_t rc);
 void prettyprint_time(char *buf, unsigned int t);
 int prettyprint_addr(union mysockaddr *addr, char *buf);
@@ -1380,7 +1394,9 @@
 int label_exception(int index, int family, union all_addr *addr);
 int fix_fd(int fd);
 int tcp_interface(int fd, int af);
+#ifdef HAVE_IPV6
 int set_ipv6pktinfo(int fd);
+#endif
 #ifdef HAVE_DHCP6
 void join_multicast(int dienow);
 #endif
--- dnsmasq/src/domain.c
+++ dnsmasq/src/domain.c
@@ -18,14 +18,21 @@
 
 
 static struct cond_domain *search_domain(struct in_addr addr, struct cond_domain *c);
+#ifdef HAVE_IPV6
 static struct cond_domain *search_domain6(struct in6_addr *addr, struct cond_domain *c);
+#endif
 
 
 int is_name_synthetic(int flags, char *name, union all_addr *addr)
 {
   char *p;
   struct cond_domain *c = NULL;
-  int prot = (flags & F_IPV6) ? AF_INET6 : AF_INET;
+  int prot = AF_INET;
+
+#ifdef HAVE_IPV6
+  if (flags & F_IPV6)
+    prot = AF_INET6;
+#endif
 
   for (c = daemon->synth_domains; c; c = c->next)
     {
@@ -76,7 +83,8 @@
 		      addr->addr4.s_addr = htonl(ntohl(c->start.s_addr) + index);
 		      found = 1;
 		    }
-		} 
+		}
+#ifdef HAVE_IPV6 
 	      else
 		{
 		  u64 index = atoll(tail);
@@ -90,6 +98,7 @@
 		      found = 1;
 		    }
 		}
+#endif
 	    }
 	}
       else
@@ -102,8 +111,10 @@
 	      if ((c >='0' && c <= '9') || c == '-')
 		continue;
 	      
+#ifdef HAVE_IPV6
 	      if (prot == AF_INET6 && ((c >='A' && c <= 'F') || (c >='a' && c <= 'f'))) 
 		continue;
+#endif
 	      
 	      break;
 	    }
@@ -113,6 +124,7 @@
 	  
 	  *p = 0;	
 	  
+#ifdef HAVE_IPV6
 	  if (prot == AF_INET6 && strstr(tail, "--ffff-") == tail)
 	    {
 	      /* special hack for v4-mapped. */
@@ -122,6 +134,7 @@
 		  *p = '.';
 	    }
 	  else
+#endif
 	    {
 	      /* swap . or : for - */
 	      for (p = tail; *p; p++)
@@ -129,8 +142,10 @@
 		  {
 		    if (prot == AF_INET)
 		      *p = '.';
+#ifdef HAVE_IPV6
 		    else
 		      *p = ':';
+#endif
 		  }
 	    }
 	  
@@ -143,6 +158,7 @@
 		      ntohl(addr->addr4.s_addr) <= ntohl(c->end.s_addr))
 		    found = 1;
 		}
+#ifdef HAVE_IPV6
 	      else
 		{
 		  u64 addrpart = addr6part(&addr->addr6);
@@ -153,6 +169,7 @@
 		      addrpart <= addr6part(&c->end6))
 		    found = 1;
 		}
+#endif
 	    }
 
 	}
@@ -204,7 +221,8 @@
        return 1;
      }
 
-   if ((flag & F_IPV6) && (c = search_domain6(&addr->addr6, daemon->synth_domains))) 
+#ifdef HAVE_IPV6
+   if ((flag & F_IPV6) && (c = search_domain6(&addr->addr6, daemon->synth_domains))) 
      {
        char *p;
        
@@ -241,6 +259,7 @@
        
        return 1;
      }
+#endif
    
    return 0;
 }
@@ -267,7 +286,7 @@
   return daemon->domain_suffix;
 } 
 
-
+#ifdef HAVE_IPV6
 static struct cond_domain *search_domain6(struct in6_addr *addr, struct cond_domain *c)
 {
   u64 addrpart = addr6part(addr);
@@ -291,3 +310,4 @@
 
   return daemon->domain_suffix;
 } 
+#endif
--- dnsmasq/src/dump.c
+++ dnsmasq/src/dump.c
@@ -82,8 +82,10 @@
 void dump_packet(int mask, void *packet, size_t len, union mysockaddr *src, union mysockaddr *dst)
 {
   struct ip ip;
+#ifdef HAVE_IPV6
   struct ip6_hdr ip6;
   int family;
+#endif
   struct udphdr {
     u16 uh_sport;               /* source port */
     u16 uh_dport;               /* destination port */
@@ -103,6 +105,7 @@
   /* So wireshark can Id the packet. */
   udp.uh_sport = udp.uh_dport = htons(NAMESERVER_PORT);
 
+#ifdef HAVE_IPV6
   if (src)
     family = src->sa.sa_family;
   else
@@ -140,6 +143,7 @@
 	}
     }
   else
+#endif
     {
       iphdr = &ip;
       ipsz = sizeof(ip);
--- dnsmasq/src/edns0.c
+++ dnsmasq/src/edns0.c
@@ -307,14 +307,20 @@
 
 struct subnet_opt {
   u16 family;
-  u8 source_netmask, scope_netmask; 
+  u8 source_netmask, scope_netmask;
+#ifdef HAVE_IPV6 
   u8 addr[IN6ADDRSZ];
+#else
+  u8 addr[INADDRSZ];
+#endif
 };
 
 static void *get_addrp(union mysockaddr *addr, const short family) 
 {
+#ifdef HAVE_IPV6
   if (family == AF_INET6)
     return &addr->in6.sin6_addr;
+#endif
 
   return &addr->in.sin_addr;
 }
@@ -331,6 +337,7 @@
   opt->source_netmask = 0;
   opt->scope_netmask = 0;
     
+#ifdef HAVE_IPV6
   if (source->sa.sa_family == AF_INET6 && daemon->add_subnet6)
     {
       opt->source_netmask = daemon->add_subnet6->mask;
@@ -343,6 +350,7 @@
       else 
 	addrp = &source->in6.sin6_addr;
     }
+#endif
 
   if (source->sa.sa_family == AF_INET && daemon->add_subnet4)
     {
@@ -357,7 +365,11 @@
 	  addrp = &source->in.sin_addr;
     }
   
+#ifdef HAVE_IPV6
   opt->family = htons(sa_family == AF_INET6 ? 2 : 1);
+#else
+  opt->family = htons(1);
+#endif
   
   if (addrp && opt->source_netmask != 0)
     {
--- dnsmasq/src/forward.c
+++ dnsmasq/src/forward.c
@@ -40,7 +40,9 @@
 #elif defined(IP_SENDSRCADDR)
     char control[CMSG_SPACE(sizeof(struct in_addr))];
 #endif
+#ifdef HAVE_IPV6
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+#endif
   } control_u;
   
   iov[0].iov_base = packet;
@@ -81,6 +83,7 @@
 #endif
 	}
       else
+#ifdef HAVE_IPV6
 	{
 	  struct in6_pktinfo p;
 	  p.ipi6_ifindex = iface; /* Need iface for IPv6 to handle link-local addrs */
@@ -91,6 +94,9 @@
 	  cmptr->cmsg_type = daemon->v6pktinfo;
 	  cmptr->cmsg_level = IPPROTO_IPV6;
 	}
+#else
+      (void)iface; /* eliminate warning */
+#endif
     }
   
   while (retry_send(sendmsg(fd, &msg, 0)));
@@ -148,8 +154,10 @@
 		flags = sflag;
 		if (serv->addr.sa.sa_family == AF_INET) 
 		  *addrpp = (union all_addr *)&serv->addr.in.sin_addr;
+#ifdef HAVE_IPV6
 		else
 		  *addrpp = (union all_addr *)&serv->addr.in6.sin6_addr;
+#endif 
 	      }
 	    else if (!flags || (flags & F_NXDOMAIN))
 	      flags = F_NOERR;
@@ -206,8 +214,10 @@
 			    flags = sflag;
 			    if (serv->addr.sa.sa_family == AF_INET) 
 			      *addrpp = (union all_addr *)&serv->addr.in.sin_addr;
+#ifdef HAVE_IPV6
 			    else
 			      *addrpp = (union all_addr *)&serv->addr.in6.sin6_addr;
+#endif
 			  }
 			else if (!flags || (flags & F_NXDOMAIN))
 			  flags = F_NOERR;
@@ -236,8 +246,10 @@
 	   /* handle F_IPV4 and F_IPV6 set on ANY query to 0.0.0.0/:: domain. */
 	   if (flags & F_IPV4)
 	     log_query((flags | F_CONFIG | F_FORWARD) & ~F_IPV6, qdomain, *addrpp, NULL);
+#ifdef HAVE_IPV6
 	   if (flags & F_IPV6)
 	     log_query((flags | F_CONFIG | F_FORWARD) & ~F_IPV4, qdomain, *addrpp, NULL);
+#endif
 	 }
     }
   else if ((*type) & SERV_USE_RESOLV)
@@ -309,17 +321,21 @@
 	  
 	  if (forward->sentto->addr.sa.sa_family == AF_INET) 
 	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, "retry", (union all_addr *)&forward->sentto->addr.in.sin_addr, "dnssec");
+#ifdef HAVE_IPV6
 	  else
 	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, "retry", (union all_addr *)&forward->sentto->addr.in6.sin6_addr, "dnssec");
+#endif
 
   
 	  if (forward->sentto->sfd)
 	    fd = forward->sentto->sfd->fd;
 	  else
 	    {
+#ifdef HAVE_IPV6
 	      if (forward->sentto->addr.sa.sa_family == AF_INET6)
 		fd = forward->rfd6->fd;
 	      else
+#endif
 		fd = forward->rfd4->fd;
 	    }
 	  
@@ -517,6 +533,7 @@
 		fd = start->sfd->fd;
 	      else 
 		{
+#ifdef HAVE_IPV6
 		  if (start->addr.sa.sa_family == AF_INET6)
 		    {
 		      if (!forward->rfd6 &&
@@ -526,6 +543,7 @@
 		      fd = forward->rfd6->fd;
 		    }
 		  else
+#endif
 		    {
 		      if (!forward->rfd4 &&
 			  !(forward->rfd4 = allocate_rfd(AF_INET)))
@@ -581,9 +599,11 @@
 		  if (start->addr.sa.sa_family == AF_INET)
 		    log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff, 
 			      (union all_addr *)&start->addr.in.sin_addr, NULL); 
+#ifdef HAVE_IPV6
 		  else
 		    log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff, 
 			      (union  all_addr *)&start->addr.in6.sin6_addr, NULL);
+#endif 
 		  start->queries++;
 		  forwarded = 1;
 		  forward->sentto = start;
@@ -823,8 +843,11 @@
   daemon->srv_save = NULL;
   
   /* Determine the address of the server replying  so that we can mark that as good */
-  if ((serveraddr.sa.sa_family = family) == AF_INET6)
+  serveraddr.sa.sa_family = family;
+#ifdef HAVE_IPV6
+  if (serveraddr.sa.sa_family == AF_INET6)
     serveraddr.in6.sin6_flowinfo = 0;
+#endif
   
   header = (struct dns_header *)daemon->packet;
 
@@ -906,6 +929,7 @@
 	    fd = start->sfd->fd;
 	  else
 	    {
+#ifdef HAVE_IPV6
 	      if (start->addr.sa.sa_family == AF_INET6)
 		{
 		  /* may have changed family */
@@ -913,6 +937,7 @@
 		    fd = forward->rfd6->fd;
 		}
 	      else
+#endif
 		{
 		  /* may have changed family */
 		  if (forward->rfd4 || (forward->rfd4 = allocate_rfd(AF_INET)))
@@ -934,8 +959,10 @@
 	  
 	  if (start->addr.sa.sa_family == AF_INET) 
 	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, "retry", (union all_addr *)&start->addr.in.sin_addr, "dnssec");
+#ifdef HAVE_IPV6
 	  else
 	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, "retry", (union all_addr *)&start->addr.in6.sin6_addr, "dnssec");
+#endif
 	  
 	  return;
 	}
@@ -1131,7 +1158,9 @@
 		      
 		      new->sentto = server;
 		      new->rfd4 = NULL;
+#ifdef HAVE_IPV6
 		      new->rfd6 = NULL;
+#endif
 		      new->frec_src.next = NULL;
 		      new->flags &= ~(FREC_DNSKEY_QUERY | FREC_DS_QUERY | FREC_HAS_EXTRADATA);
 		      new->forwardall = 0;
@@ -1156,9 +1185,11 @@
 		      if (server->addr.sa.sa_family == AF_INET) 
 			log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, daemon->keyname, (union all_addr *)&(server->addr.in.sin_addr),
 				  querystr("dnssec-query", querytype));
+#ifdef HAVE_IPV6
 		      else
 			log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, daemon->keyname, (union all_addr *)&(server->addr.in6.sin6_addr),
 				  querystr("dnssec-query", querytype));
+#endif
   
 		      memcpy(new->hash, hash_questions(header, nn, daemon->namebuff), HASH_SIZE);
 		      new->new_id = get_id();
@@ -1175,12 +1206,14 @@
 		      else
 			{
 			  fd = -1;
+#ifdef HAVE_IPV6
 			  if (server->addr.sa.sa_family == AF_INET6)
 			    {
 			      if (new->rfd6 || (new->rfd6 = allocate_rfd(AF_INET6)))
 				fd = new->rfd6->fd;
 			    }
 			  else
+#endif
 			    {
 			      if (new->rfd4 || (new->rfd4 = allocate_rfd(AF_INET)))
 				fd = new->rfd4->fd;
@@ -1337,7 +1370,9 @@
   struct cmsghdr *cmptr;
   union {
     struct cmsghdr align; /* this ensures alignment */
+#ifdef HAVE_IPV6
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+#endif
 #if defined(HAVE_LINUX_NETWORK)
     char control[CMSG_SPACE(sizeof(struct in_pktinfo))];
 #elif defined(IP_RECVDSTADDR) && defined(HAVE_SOLARIS_NETWORK)
@@ -1349,8 +1384,12 @@
 #endif
   } control_u;
   int family = listen->addr.sa.sa_family;
+#ifdef HAVE_IPV6
    /* Can always get recvd interface for IPv6 */
   int check_dst = !option_bool(OPT_NOWILD) || family == AF_INET6;
+#else
+  int check_dst = !option_bool(OPT_NOWILD);
+#endif
 
   /* packet buffer overwritten */
   daemon->srv_save = NULL;
@@ -1401,6 +1440,7 @@
       if (source_addr.in.sin_port == 0)
 	return;
     }
+#ifdef HAVE_IPV6
   else
     {
       /* Source-port == 0 is an error, we can't send back to that. */
@@ -1408,12 +1448,14 @@
 	return;
       source_addr.in6.sin6_flowinfo = 0;
     }
+#endif
   
   /* We can be configured to only accept queries from at-most-one-hop-away addresses. */
   if (option_bool(OPT_LOCAL_SERVICE))
     {
       struct addrlist *addr;
 
+#ifdef HAVE_IPV6
       if (family == AF_INET6) 
 	{
 	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
@@ -1422,6 +1464,7 @@
 	      break;
 	}
       else
+#endif
 	{
 	  struct in_addr netmask;
 	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
@@ -1490,6 +1533,7 @@
 	}
 #endif
       
+#ifdef HAVE_IPV6
       if (family == AF_INET6)
 	{
 	  for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
@@ -1505,6 +1549,7 @@
 		if_index = p.p->ipi6_ifindex;
 	      }
 	}
+#endif
       
       /* enforce available interface configuration */
       
@@ -1568,9 +1613,11 @@
       if (family == AF_INET) 
 	log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff, 
 		  (union all_addr *)&source_addr.in.sin_addr, types);
+#ifdef HAVE_IPV6
       else
 	log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff, 
 		  (union all_addr *)&source_addr.in6.sin6_addr, types);
+#endif
 
 #ifdef HAVE_AUTH
       /* find queries for zones we're authoritative for, and answer them directly */
@@ -1795,9 +1842,11 @@
 	  if (server->addr.sa.sa_family == AF_INET) 
 	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, keyname, (union all_addr *)&(server->addr.in.sin_addr),
 		      querystr("dnssec-query", new_status == STAT_NEED_KEY ? T_DNSKEY : T_DS));
+#ifdef HAVE_IPV6
 	  else
 	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, keyname, (union all_addr *)&(server->addr.in6.sin6_addr),
 		      querystr("dnssec-query", new_status == STAT_NEED_KEY ? T_DNSKEY : T_DS));
+#endif
 	  
 	  server->flags |= SERV_GOT_TCP;
 	  
@@ -1863,9 +1912,11 @@
     {
       union all_addr local;
 		      
+#ifdef HAVE_IPV6
       if (local_addr->sa.sa_family == AF_INET6)
 	local.addr6 = local_addr->in6.sin6_addr;
       else
+#endif
 	local.addr4 = local_addr->in.sin_addr;
       
       have_mark = get_incoming_mark(&peer_addr, &local, 1, &mark);
@@ -1877,6 +1928,7 @@
     {
       struct addrlist *addr;
 
+#ifdef HAVE_IPV6
       if (peer_addr.sa.sa_family == AF_INET6) 
 	{
 	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
@@ -1885,6 +1937,7 @@
 	      break;
 	}
       else
+#endif
 	{
 	  struct in_addr netmask;
 	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
@@ -1939,9 +1992,11 @@
 	  if (peer_addr.sa.sa_family == AF_INET) 
 	    log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff, 
 		      (union all_addr *)&peer_addr.in.sin_addr, types);
+#ifdef HAVE_IPV6
 	  else
 	    log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff, 
 		      (union all_addr *)&peer_addr.in6.sin6_addr, types);
+#endif
 	  
 #ifdef HAVE_AUTH
 	  /* find queries for zones we're authoritative for, and answer them directly */
@@ -2127,9 +2182,11 @@
 		      if (last_server->addr.sa.sa_family == AF_INET)
 			log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff, 
 				  (union all_addr *)&last_server->addr.in.sin_addr, NULL); 
+#ifdef HAVE_IPV6
 		      else
 			log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff, 
 				  (union all_addr *)&last_server->addr.in6.sin6_addr, NULL);
+#endif 
 
 #ifdef HAVE_DNSSEC
 		      if (option_bool(OPT_DNSSEC_VALID) && !checking_disabled && (last_server->flags & SERV_DO_DNSSEC))
@@ -2224,7 +2281,9 @@
       f->sentto = NULL;
       f->rfd4 = NULL;
       f->flags = 0;
+#ifdef HAVE_IPV6
       f->rfd6 = NULL;
+#endif
 #ifdef HAVE_DNSSEC
       f->dependent = NULL;
       f->blocking_query = NULL;
@@ -2295,8 +2354,11 @@
   f->rfd4 = NULL;
   f->sentto = NULL;
   f->flags = 0;
+  
+#ifdef HAVE_IPV6
   free_rfd(f->rfd6);
   f->rfd6 = NULL;
+#endif
 
 #ifdef HAVE_DNSSEC
   if (f->stash)
@@ -2415,8 +2477,10 @@
 	if (family == AF_INET && f->rfd4 && f->rfd4->fd == fd)
 	  return f;
 
+#ifdef HAVE_IPV6
 	if (family == AF_INET6 && f->rfd6 && f->rfd6->fd == fd)
 	  return f;
+#endif
 
 	/* sent to upstream from bound socket. */
 	if (f->sentto->sfd && f->sentto->sfd->fd == fd)
--- dnsmasq/src/helper.c
+++ dnsmasq/src/helper.c
@@ -64,7 +64,9 @@
 #ifdef HAVE_TFTP
   off_t file_len;
 #endif
+#ifdef HAVE_IPV6
   struct in6_addr addr6;
+#endif
 #ifdef HAVE_DHCP6
   int vendorclass_count;
   unsigned int iaid;
@@ -303,8 +305,10 @@
     
       if (!is6)
 	inet_ntop(AF_INET, &data.addr, daemon->addrbuff, ADDRSTRLEN);
+#ifdef HAVE_IPV6
       else
 	inet_ntop(AF_INET6, &data.addr6, daemon->addrbuff, ADDRSTRLEN);
+#endif
 
 #ifdef HAVE_TFTP
       /* file length */
@@ -825,8 +829,10 @@
 
   if ((buf->flags = peer->sa.sa_family) == AF_INET)
     buf->addr = peer->in.sin_addr;
+#ifdef HAVE_IPV6
   else
     buf->addr6 = peer->in6.sin6_addr;
+#endif
 
   memcpy((unsigned char *)(buf+1), filename, filename_len);
   
@@ -848,8 +854,10 @@
   buf->hwaddr_type =  ARPHRD_ETHER; 
   if ((buf->flags = family) == AF_INET)
     buf->addr = addr->addr4;
+#ifdef HAVE_IPV6
   else
     buf->addr6 = addr->addr6;
+#endif
   
   memcpy(buf->hwaddr, mac, maclen);
   
--- dnsmasq/src/ipset.c
+++ dnsmasq/src/ipset.c
@@ -105,8 +105,13 @@
   struct my_nfgenmsg *nfg;
   struct my_nlattr *nested[2];
   uint8_t proto;
-  int addrsz = (af == AF_INET6) ? IN6ADDRSZ : INADDRSZ;
+  int addrsz = INADDRSZ;
 
+#ifdef HAVE_IPV6
+  if (af == AF_INET6)
+    addrsz = IN6ADDRSZ;
+#endif
+
   if (strlen(setname) >= IPSET_MAXNAMELEN) 
     {
       errno = ENAMETOOLONG;
@@ -193,6 +198,7 @@
 {
   int ret = 0, af = AF_INET;
 
+#ifdef HAVE_IPV6
   if (flags & F_IPV6)
     {
       af = AF_INET6;
@@ -203,6 +209,7 @@
 	  ret = -1;
 	}
     }
+#endif
   
   if (ret != -1) 
     ret = old_kernel ? old_add_to_ipset(setname, ipaddr, remove) : new_add_to_ipset(setname, ipaddr, af, remove);
--- dnsmasq/src/netlink.c
+++ dnsmasq/src/netlink.c
@@ -61,10 +61,11 @@
   addr.nl_groups = RTMGRP_IPV4_ROUTE;
   if (option_bool(OPT_CLEVERBIND))
     addr.nl_groups |= RTMGRP_IPV4_IFADDR;  
+#ifdef HAVE_IPV6
   addr.nl_groups |= RTMGRP_IPV6_ROUTE;
   if (option_bool(OPT_CLEVERBIND))
     addr.nl_groups |= RTMGRP_IPV6_IFADDR;
-
+#endif
 #ifdef HAVE_DHCP6
   if (daemon->doing_ra || daemon->doing_dhcp6)
     addr.nl_groups |= RTMGRP_IPV6_IFADDR;
@@ -251,6 +252,7 @@
 		      if (!((*callback)(addr, ifa->ifa_index, label,  netmask, broadcast, parm)))
 			callback_ok = 0;
 		  }
+#ifdef HAVE_IPV6
 		else if (ifa->ifa_family == AF_INET6)
 		  {
 		    struct in6_addr *addrp = NULL;
@@ -285,6 +287,7 @@
 					(int) preferred, (int)valid, parm)))
 			callback_ok = 0;
 		  }
+#endif
 	      }
 	  }
 	else if (h->nlmsg_type == RTM_NEWNEIGH && family == AF_UNSPEC)
--- dnsmasq/src/network.c
+++ dnsmasq/src/network.c
@@ -137,10 +137,12 @@
 	      if (family == AF_INET &&
 		  tmp->addr.in.sin_addr.s_addr == addr->addr4.s_addr)
 		ret = match_addr = tmp->used = 1;
+#ifdef HAVE_IPV6
 	      else if (family == AF_INET6 &&
 		       IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, 
 					  &addr->addr6))
 		ret = match_addr = tmp->used = 1;
+#endif
 	    }          
     }
   
@@ -160,9 +162,11 @@
     else if (addr && tmp->addr.sa.sa_family == AF_INET && family == AF_INET &&
 	     tmp->addr.in.sin_addr.s_addr == addr->addr4.s_addr)
       break;
+#ifdef HAVE_IPV6
     else if (addr && tmp->addr.sa.sa_family == AF_INET6 && family == AF_INET6 &&
 	     IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, &addr->addr6))
       break;
+#endif
 
   if (tmp && auth) 
     {
@@ -196,8 +200,10 @@
 		if (iface->addr.in.sin_addr.s_addr == addr->addr4.s_addr)
 		  return 1;
 	      }
+#ifdef HAVE_IPV6
 	    else if (IN6_ARE_ADDR_EQUAL(&iface->addr.in6.sin6_addr, &addr->addr6))
 	      return 1;
+#endif
 	  }
     }
   return 0;
@@ -285,15 +291,19 @@
 	      al->addr.addr4 = addr->in.sin_addr;
 	      al->flags = 0;
 	    }
+#ifdef HAVE_IPV6
 	  else
 	    {
 	      al->addr.addr6 = addr->in6.sin6_addr;
 	      al->flags = ADDRLIST_IPV6;
 	    } 
+#endif
 	}
     }
   
+#ifdef HAVE_IPV6
   if (addr->sa.sa_family != AF_INET6 || !IN6_IS_ADDR_LINKLOCAL(&addr->in6.sin6_addr))
+#endif
     {
       struct interface_name *int_name;
       struct addrlist *al;
@@ -326,6 +336,7 @@
 		    }
 		}
 	      
+#ifdef HAVE_IPV6
 	      if (addr->sa.sa_family == AF_INET6 && (name->flags & AUTH6))
 		{
 		  if (param->spare)
@@ -345,6 +356,7 @@
 		      al->flags = ADDRLIST_IPV6;
 		    }
 		} 
+#endif
 	    }
 #endif
        
@@ -372,6 +384,7 @@
 		    al->addr.addr4 = addr->in.sin_addr;
 		    al->flags = 0;
 		  }
+#ifdef HAVE_IPV6
 		else
 		 {
 		    al->addr.addr6 = addr->in6.sin6_addr;
@@ -381,6 +394,7 @@
 		    if (!(iface_flags & IFACE_PERMANENT) || (iface_flags & (IFACE_DEPRECATED | IFACE_TENTATIVE)))
 		      al->flags |= ADDRLIST_REVONLY;
 		 } 
+#endif
 	      }
 	  }
     }
@@ -423,9 +437,11 @@
       !iface_check(AF_INET, (union all_addr *)&addr->in.sin_addr, label, &auth_dns))
     return 1;
 
+#ifdef HAVE_IPV6
   if (addr->sa.sa_family == AF_INET6 &&
       !iface_check(AF_INET6, (union all_addr *)&addr->in6.sin6_addr, label, &auth_dns))
     return 1;
+#endif
     
 #ifdef HAVE_DHCP
   /* No DHCP where we're doing auth DNS. */
@@ -484,6 +500,7 @@
   return 0;
 }
 
+#ifdef HAVE_IPV6
 static int iface_allowed_v6(struct in6_addr *local, int prefix, 
 			    int scope, int if_index, int flags, 
 			    int preferred, int valid, void *vparam)
@@ -511,6 +528,7 @@
   
   return iface_allowed((struct iface_param *)vparam, if_index, NULL, &addr, netmask, prefix, flags);
 }
+#endif
 
 static int iface_allowed_v4(struct in_addr local, int if_index, char *label,
 			    struct in_addr netmask, struct in_addr broadcast, void *vparam)
@@ -689,7 +707,9 @@
 
   param.spare = spare;
   
+#ifdef HAVE_IPV6
   ret = iface_enumerate(AF_INET6, &param, iface_allowed_v6);
+#endif
 
   if (ret)
     ret = iface_enumerate(AF_INET, &param, iface_allowed_v4); 
@@ -787,8 +807,10 @@
   if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1 || !fix_fd(fd))
     goto err;
   
+#ifdef HAVE_IPV6
   if (family == AF_INET6 && setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &opt, sizeof(opt)) == -1)
     goto err;
+#endif
   
   if ((rc = bind(fd, (struct sockaddr *)addr, sa_len(addr))) == -1)
     goto err;
@@ -817,12 +839,15 @@
 #endif
 	}
     }
+#ifdef HAVE_IPV6
   else if (!set_ipv6pktinfo(fd))
     goto err;
+#endif
   
   return fd;
 }
 
+#ifdef HAVE_IPV6  
 int set_ipv6pktinfo(int fd)
 {
   int opt = 1;
@@ -849,6 +874,7 @@
 
   return 0;
 }
+#endif
 
 
 /* Find the interface on which a TCP connection arrived, if possible, or zero otherwise. */
@@ -890,6 +916,7 @@
 	      }
 	}
     }
+#ifdef HAVE_IPV6
   else
     {
       /* Only the RFC-2292 API has the ability to find the interface for TCP connections,
@@ -921,6 +948,7 @@
               }
 	}
     }
+#endif /* IPV6 */
 #endif /* Linux */
  
   return if_index;
@@ -950,6 +978,7 @@
 	  tftpfd = make_sock(addr, SOCK_DGRAM, dienow);
 	  addr->in.sin_port = save;
 	}
+#  ifdef HAVE_IPV6
       else
 	{
 	  short save = addr->in6.sin6_port;
@@ -957,6 +986,7 @@
 	  tftpfd = make_sock(addr, SOCK_DGRAM, dienow);
 	  addr->in6.sin6_port = save;
 	}  
+#  endif
     }
 #endif
 
@@ -990,6 +1020,7 @@
 
   l = create_listeners(&addr, !!option_bool(OPT_TFTP), 1);
 
+#ifdef HAVE_IPV6
   memset(&addr, 0, sizeof(addr));
 #ifdef HAVE_SOCKADDR_SA_LEN
   addr.in6.sin6_len = sizeof(addr.in6);
@@ -1003,6 +1034,7 @@
     l->next = l6;
   else 
     l = l6;
+#endif
 
   daemon->listeners = l;
 }
@@ -1236,6 +1268,7 @@
 		addr.in.sin_len = sizeof(struct sockaddr_in);
 #endif
 	      }
+#ifdef HAVE_IPV6
 	    else
 	      {
 		addr.in6.sin6_addr = in6addr_any; 
@@ -1244,6 +1277,7 @@
 		addr.in6.sin6_len = sizeof(struct sockaddr_in6);
 #endif
 	      }
+#endif
 	    
 	    if (bind(fd, (struct sockaddr *)&addr, sa_len(&addr)) == 0)
 	      return fd;
@@ -1268,8 +1302,10 @@
  
   if (addr_copy.sa.sa_family == AF_INET)
     port = addr_copy.in.sin_port;
+#ifdef HAVE_IPV6
   else
     port = addr_copy.in6.sin6_port;
+#endif
 
   /* cannot set source _port_ for TCP connections. */
   if (is_tcp)
@@ -1286,8 +1322,10 @@
     {
       if (addr_copy.sa.sa_family == AF_INET)
 	addr_copy.in.sin_port = port;
+#ifdef HAVE_IPV6
       else
 	addr_copy.in6.sin6_port = port;
+#endif
 
       if (bind(fd, (struct sockaddr *)&addr_copy, sa_len(&addr_copy)) != -1)
 	{
@@ -1313,7 +1351,7 @@
           return setsockopt(fd, IPPROTO_IP, IP_UNICAST_IF, &ifindex_opt, sizeof(ifindex_opt)) == 0;
         }
 #endif
-#if defined (IPV6_UNICAST_IF)
+#if defined(HAVE_IPV6) && defined (IPV6_UNICAST_IF)
       if (addr_copy.sa.sa_family == AF_INET6)
         {
           uint32_t ifindex_opt = htonl(ifindex);
@@ -1350,10 +1388,12 @@
 	  addr->in.sin_port == htons(0)) 
 	return NULL;
 
+#ifdef HAVE_IPV6
       if (addr->sa.sa_family == AF_INET6 &&
 	  memcmp(&addr->in6.sin6_addr, &in6addr_any, sizeof(in6addr_any)) == 0 &&
 	  addr->in6.sin6_port == htons(0)) 
 	return NULL;
+#endif
     }
 
   if (intname && strlen(intname) != 0)
@@ -1417,6 +1457,7 @@
       if ((sfd = allocate_sfd(&addr, "")))
 	sfd->preallocated = 1;
 
+#ifdef HAVE_IPV6
       memset(&addr, 0, sizeof(addr));
       addr.in6.sin6_family = AF_INET6;
       addr.in6.sin6_addr = in6addr_any;
@@ -1426,6 +1467,7 @@
 #endif
       if ((sfd = allocate_sfd(&addr, "")))
 	sfd->preallocated = 1;
+#endif
     }
   
   for (srv = daemon->servers; srv; srv = srv->next)
@@ -1758,6 +1800,7 @@
 	  source_addr.in.sin_addr.s_addr = INADDR_ANY;
 	  source_addr.in.sin_port = htons(daemon->query_port);
 	}
+#ifdef HAVE_IPV6
       else 
 	{	
 	  int scope_index = 0;
@@ -1785,6 +1828,10 @@
 	  else
 	    continue;
 	}
+#else /* IPV6 */
+      else
+	continue;
+#endif 
 
       add_update_server(SERV_FROM_RESOLV, &addr, &source_addr, NULL, NULL);
       gotone = 1;
--- dnsmasq/src/option.c
+++ dnsmasq/src/option.c
@@ -773,8 +773,10 @@
 {
   if (inet_pton(AF_INET, arg, &addr->in.sin_addr) > 0)
     addr->sa.sa_family = AF_INET;
+#ifdef HAVE_IPV6
   else if (inet_pton(AF_INET6, arg, &addr->in6.sin6_addr) > 0)
     addr->sa.sa_family = AF_INET6;
+#endif
   else
     return _("bad address");
    
@@ -786,8 +788,10 @@
   int source_port = 0, serv_port = NAMESERVER_PORT;
   char *portno, *source;
   char *interface_opt = NULL;
+#ifdef HAVE_IPV6
   int scope_index = 0;
   char *scope_id;
+#endif
   
   if (!arg || strlen(arg) == 0)
     {
@@ -805,7 +809,9 @@
       !atoi_check16(portno, &serv_port))
     return _("bad port");
   
+#ifdef HAVE_IPV6
   scope_id = split_chr(arg, '%');
+#endif
   
   if (source) {
     interface_opt = split_chr(source, '@');
@@ -849,6 +855,7 @@
 	    }
 	}
     }
+#ifdef HAVE_IPV6
   else if (inet_pton(AF_INET6, arg, &addr->in6.sin6_addr) > 0)
     {
       if (scope_id && (scope_index = if_nametoindex(scope_id)) == 0)
@@ -883,6 +890,7 @@
 	    }
 	}
     }
+#endif
   else
     return _("bad address");
 
@@ -2070,8 +2078,10 @@
 	  unhide_metas(arg);
 	  if (inet_pton(AF_INET, arg, &new->addr.in.sin_addr) > 0)
 	    new->addr.sa.sa_family = AF_INET;
+#ifdef HAVE_IPV6
 	  else if (inet_pton(AF_INET6, arg, &new->addr.in6.sin6_addr) > 0)
 	    new->addr.sa.sa_family = AF_INET6;
+#endif
 	  else
 	    {
 	      char *fam = split_chr(arg, '/');
@@ -2081,8 +2091,10 @@
 		{
 		  if (strcmp(fam, "4") == 0)
 		    new->addr.sa.sa_family = AF_INET;
+#ifdef HAVE_IPV6
 		  else if (strcmp(fam, "6") == 0)
 		    new->addr.sa.sa_family = AF_INET6;
+#endif
 		  else
 		  {
 		    free(new->name);
@@ -2151,12 +2163,14 @@
 		subnet->prefixlen = (prefixlen == 0) ? 24 : prefixlen;
 		subnet->flags = ADDRLIST_LITERAL;
 	      }
+#ifdef HAVE_IPV6
 	    else if (inet_pton(AF_INET6, arg, &addr.addr6))
 	      {
 		subnet = opt_malloc(sizeof(struct addrlist));
 		subnet->prefixlen = (prefixlen == 0) ? 64 : prefixlen;
 		subnet->flags = ADDRLIST_LITERAL | ADDRLIST_IPV6;
 	      }
+#endif
 	    else 
 	      {
 		struct auth_name_list *name =  opt_malloc(sizeof(struct auth_name_list));
@@ -2168,8 +2182,10 @@
 		  {
 		    if (prefixlen == 4)
 		      name->flags &= ~AUTH6;
+#ifdef HAVE_IPV6
 		    else if (prefixlen == 6)
 		      name->flags &= ~AUTH4;
+#endif
 		    else
 		      ret_err(gen_err);
 		  }
@@ -2290,6 +2306,7 @@
 				}
 			    }
 			}
+#ifdef HAVE_IPV6
 		      else if (inet_pton(AF_INET6, comma, &new->start6))
 			{
 			  u64 mask = (1LLU << (128 - msize)) - 1LLU;
@@ -2333,6 +2350,7 @@
 				}
 			    }
 			}
+#endif
 		      else
 			ret_err_free(gen_err, new);
 		    }
@@ -2350,6 +2368,7 @@
 			  else if (!inet_pton(AF_INET, arg, &new->end))
 			    ret_err_free(gen_err, new);
 			}
+#ifdef HAVE_IPV6
 		      else if (inet_pton(AF_INET6, comma, &new->start6))
 			{
 			  new->is6 = 1;
@@ -2358,6 +2377,7 @@
 			  else if (!inet_pton(AF_INET6, arg, &new->end6))
 			    ret_err_free(gen_err, new);
 			}
+#endif
 		      else 
 			ret_err_free(gen_err, new);
 
@@ -2516,6 +2536,7 @@
 	    new->addr.in.sin_len = sizeof(new->addr.in);
 #endif
 	  }
+#ifdef HAVE_IPV6
 	else if (arg && inet_pton(AF_INET6, arg, &new->addr.in6.sin6_addr) > 0)
 	  {
 	    new->addr.sa.sa_family = AF_INET6;
@@ -2526,6 +2547,7 @@
 	    new->addr.in6.sin6_len = sizeof(new->addr.in6);
 #endif
 	  }
+#endif
 	else
 	  ret_err_free(gen_err, new);
 
@@ -2644,7 +2666,9 @@
 	int size;
 	struct server *serv;
 	struct in_addr addr4;
+#ifdef HAVE_IPV6
 	struct in6_addr addr6;
+#endif
  
 	unhide_metas(arg);
 	if (!arg)
@@ -2661,8 +2685,10 @@
 	    if (!serv)
 	      ret_err(_("bad prefix"));
 	  }
+#ifdef HAVE_IPV6
 	else if (inet_pton(AF_INET6, arg, &addr6))
 	  serv = add_rev6(&addr6, size);
+#endif
 	else
 	  ret_err(gen_err);
  
@@ -4099,8 +4125,10 @@
 	  {
 	    if (strcmp(arg, "4") == 0)
 	      new->family = AF_INET;
+#ifdef HAVE_IPV6
 	    else if (strcmp(arg, "6") == 0)
 	      new->family = AF_INET6;
+#endif
 	    else
 	      ret_err_free(gen_err, new);
 	  } 
@@ -4424,11 +4452,13 @@
 		new->addr = addr.addr4;
 		new->flags |= HR_4;
 	      }
+#ifdef HAVE_IPV6
 	    else if (inet_pton(AF_INET6, arg, &addr.addr6))
 	      {
 		new->addr6 = addr.addr6;
 		new->flags |= HR_6;
 	      }
+#endif
 	    else
 	      {
 		int nomem;
@@ -5155,8 +5185,10 @@
 	  {
 	    if (tmp->source_addr.sa.sa_family == AF_INET)
 	      tmp->source_addr.in.sin_port = htons(daemon->query_port);
+#ifdef HAVE_IPV6
 	    else if (tmp->source_addr.sa.sa_family == AF_INET6)
 	      tmp->source_addr.in6.sin6_port = htons(daemon->query_port);
+#endif 
 	  }
     } 
   
@@ -5217,8 +5249,10 @@
       for(tmp = daemon->if_addrs; tmp; tmp = tmp->next)
 	if (tmp->addr.sa.sa_family == AF_INET)
 	  tmp->addr.in.sin_port = htons(daemon->port);
+#ifdef HAVE_IPV6
 	else if (tmp->addr.sa.sa_family == AF_INET6)
 	  tmp->addr.in6.sin6_port = htons(daemon->port);
+#endif
     }
 	
   /* create default, if not specified */
--- dnsmasq/src/rfc1035.c
+++ dnsmasq/src/rfc1035.c
@@ -198,6 +198,7 @@
 
       return F_IPV4;
     }
+#ifdef HAVE_IPV6
   else if (hostname_isequal(penchunk, "ip6") && 
 	   (hostname_isequal(lastchunk, "int") || hostname_isequal(lastchunk, "arpa")))
     {
@@ -242,6 +243,7 @@
 	  return F_IPV6;
 	}
     }
+#endif
   
   return 0;
 }
@@ -375,6 +377,7 @@
     ((ip_addr & 0xFFFFFFFF) == 0xFFFFFFFF)  /* 255.255.255.255/32 (broadcast)*/ ;
 }
 
+#ifdef HAVE_IPV6
 static int private_net6(struct in6_addr *a)
 {
   return 
@@ -384,6 +387,8 @@
     ((unsigned char *)a)[0] == 0xfd ||   /* RFC 6303 4.4 */
     ((u32 *)a)[0] == htonl(0x20010db8); /* RFC 6303 4.6 */
 }
+#endif
+
 
 static unsigned char *do_doctor(unsigned char *p, int count, struct dns_header *header, size_t qlen, char *name, int *doctored)
 {
@@ -687,11 +692,13 @@
 	      addrlen = INADDRSZ;
 	      flags |= F_IPV4;
 	    }
+#ifdef HAVE_IPV6
 	  else if (qtype == T_AAAA)
 	    {
 	      addrlen = IN6ADDRSZ;
 	      flags |= F_IPV6;
 	    }
+#endif
 	  else if (qtype == T_SRV)
 	    flags |= F_SRV;
 	  else
@@ -795,6 +802,7 @@
 				  private_net(addr.addr4, !option_bool(OPT_LOCAL_REBIND)))
 				return 1;
 
+#ifdef HAVE_IPV6
 			      /* Block IPv4-mapped IPv6 addresses in private IPv4 address space */
 			      if (flags & F_IPV6)
 				{
@@ -817,6 +825,7 @@
 				      IN6_IS_ADDR_LOOPBACK(&addr.addr6))
 				    return 1;
 				}
+#endif
 			    }
 
 #ifdef HAVE_IPSET
@@ -963,6 +972,7 @@
 	  add_resource_record(header, NULL, NULL, sizeof(struct dns_header), &p, ttl, NULL, T_A, C_IN, "4", addrp);
 	}
       
+#ifdef HAVE_IPV6
       if (flags & F_IPV6)
 	{
 	  SET_RCODE(header, NOERROR);
@@ -970,6 +980,7 @@
 	  header->hb3 |= HB3_AA;
 	  add_resource_record(header, NULL, NULL, sizeof(struct dns_header), &p, ttl, NULL, T_AAAA, C_IN, "6", addrp);
 	}
+#endif
     }
   else /* nowhere to forward to */
     {
@@ -1159,12 +1170,14 @@
   for (; *format; format++)
     switch (*format)
       {
+#ifdef HAVE_IPV6
       case '6':
         CHECK_LIMIT(IN6ADDRSZ);
 	sval = va_arg(ap, char *); 
 	memcpy(p, sval, IN6ADDRSZ);
 	p += IN6ADDRSZ;
 	break;
+#endif
 	
       case '4':
         CHECK_LIMIT(INADDRSZ);
@@ -1462,6 +1475,7 @@
 		      while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
 			intr = intr->next;
 		  }
+#ifdef HAVE_IPV6
 	      else if (is_arpa == F_IPV6)
 		for (intr = daemon->int_names; intr; intr = intr->next)
 		  {
@@ -1477,6 +1491,7 @@
 		      while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
 			intr = intr->next;
 		  }
+#endif
 	      
 	      if (intr)
 		{
@@ -1567,7 +1582,9 @@
 		    }
 		}
 	      else if (option_bool(OPT_BOGUSPRIV) && (
+#ifdef HAVE_IPV6
 		       (is_arpa == F_IPV6 && private_net6(&addr.addr6)) ||
+#endif
 		       (is_arpa == F_IPV4 && private_net(addr.addr4, 1))))
 		{
 		  struct server *serv;
@@ -1608,9 +1625,16 @@
 
 	  for (flag = F_IPV4; flag; flag = (flag == F_IPV4) ? F_IPV6 : 0)
 	    {
-	      unsigned short type = (flag == F_IPV6) ? T_AAAA : T_A;
+	      unsigned short type = T_A;
 	      struct interface_name *intr;
 
+	      if (flag == F_IPV6)
+#ifdef HAVE_IPV6
+		type = T_AAAA;
+#else
+	        break;
+#endif
+
 	      if (qtype != type && qtype != T_ANY)
 		continue;
 	      
@@ -1632,26 +1656,31 @@
 		    for (intr = daemon->int_names; intr; intr = intr->next)
 		      if (hostname_isequal(name, intr->name))
 			for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
-			  if (!(addrlist->flags & ADDRLIST_IPV6) && 
-			      is_same_net(addrlist->addr.addr4, local_addr, local_netmask))
-			    {
-			      localise = 1;
-			      break;
-			    }
+#ifdef HAVE_IPV6
+			  if (!(addrlist->flags & ADDRLIST_IPV6))
+#endif
+			    if (is_same_net(addrlist->addr.addr4, local_addr, local_netmask))
+			      {
+				localise = 1;
+				break;
+			      }
 		  
 		  for (intr = daemon->int_names; intr; intr = intr->next)
 		    if (hostname_isequal(name, intr->name))
 		      {
 			for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
+#ifdef HAVE_IPV6
 			  if (((addrlist->flags & ADDRLIST_IPV6) ? T_AAAA : T_A) == type)
+#endif
 			    {
 			      if (localise && 
 				  !is_same_net(addrlist->addr.addr4, local_addr, local_netmask))
 				continue;
 
+#ifdef HAVE_IPV6
 			      if (addrlist->flags & ADDRLIST_REVONLY)
 				continue;
-
+#endif
 			      ans = 1;	
 			      sec_data = 0;
 			      if (!dryrun)
@@ -1931,8 +1960,11 @@
 	crecp = NULL;
 	while ((crecp = cache_find_by_name(crecp, rec->target, now, F_IPV4 | F_IPV6)))
 	  {
+#ifdef HAVE_IPV6
 	    int type =  crecp->flags & F_IPV4 ? T_A : T_AAAA;
-
+#else
+	    int type = T_A;
+#endif
 	    if (crecp->flags & F_NEG)
 	      continue;
 
--- dnsmasq/src/tables.c
+++ dnsmasq/src/tables.c
@@ -108,7 +108,7 @@
     my_syslog(LOG_INFO, _("info: table created"));
  
   bzero(&addr, sizeof(addr));
-
+#ifdef HAVE_IPV6
   if (flags & F_IPV6) 
     {
       addr.pfra_af = AF_INET6;
@@ -116,6 +116,7 @@
       memcpy(&(addr.pfra_ip6addr), ipaddr, sizeof(struct in6_addr));
     } 
   else 
+#endif
     {
       addr.pfra_af = AF_INET;
       addr.pfra_net = 0x20;
--- dnsmasq/src/tftp.c
+++ dnsmasq/src/tftp.c
@@ -62,11 +62,17 @@
   struct tftp_prefix *pref;
   union all_addr addra;
   int family = listen->addr.sa.sa_family;
+#ifdef HAVE_IPV6
   /* Can always get recvd interface for IPv6 */
   int check_dest = !option_bool(OPT_NOWILD) || family == AF_INET6;
+#else
+  int check_dest = !option_bool(OPT_NOWILD);
+#endif
   union {
     struct cmsghdr align; /* this ensures alignment */
+#ifdef HAVE_IPV6
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+#endif
 #if defined(HAVE_LINUX_NETWORK)
     char control[CMSG_SPACE(sizeof(struct in_pktinfo))];
 #elif defined(HAVE_SOLARIS_NETWORK)
@@ -172,6 +178,7 @@
 	  
 #endif
 
+#ifdef HAVE_IPV6
       if (family == AF_INET6)
         {
           for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
@@ -187,6 +194,7 @@
                 if_index = p.p->ipi6_ifindex;
               }
         }
+#endif
       
       if (!indextoname(listen->tftpfd, if_index, namebuff))
 	return;
@@ -195,8 +203,10 @@
       
       addra.addr4 = addr.in.sin_addr;
 
+#ifdef HAVE_IPV6
       if (family == AF_INET6)
 	addra.addr6 = addr.in6.sin6_addr;
+#endif
 
       if (daemon->tftp_interfaces)
 	{
@@ -289,6 +299,7 @@
       addr.in.sin_len = sizeof(addr.in);
 #endif
     }
+#ifdef HAVE_IPV6
   else
     {
       addr.in6.sin6_port = htons(port);
@@ -298,6 +309,7 @@
       addr.in6.sin6_len = sizeof(addr.in6);
 #endif
     }
+#endif
 
   /* May reuse struct transfer from abandoned transfer in single port mode. */
   if (!transfer && !(transfer = whine_malloc(sizeof(struct tftp_transfer))))
@@ -340,9 +352,11 @@
 		{ 
 		  if (family == AF_INET)
 		    addr.in.sin_port = htons(port);
+#ifdef HAVE_IPV6
 		  else
 		    addr.in6.sin6_port = htons(port);
+#endif
 		  
 		  continue;
 		}
 	      my_syslog(MS_TFTP | LOG_ERR, _("unable to get free port for TFTP"));
--- dnsmasq/src/util.c
+++ dnsmasq/src/util.c
@@ -324,12 +324,13 @@
 	  s1->in.sin_port == s2->in.sin_port &&
 	  s1->in.sin_addr.s_addr == s2->in.sin_addr.s_addr)
 	return 1;
-      
+#ifdef HAVE_IPV6      
       if (s1->sa.sa_family == AF_INET6 &&
 	  s1->in6.sin6_port == s2->in6.sin6_port &&
 	  s1->in6.sin6_scope_id == s2->in6.sin6_scope_id &&
 	  IN6_ARE_ADDR_EQUAL(&s1->in6.sin6_addr, &s2->in6.sin6_addr))
 	return 1;
+#endif
     }
   return 0;
 }
@@ -339,9 +340,11 @@
 #ifdef HAVE_SOCKADDR_SA_LEN
   return addr->sa.sa_len;
 #else
+#ifdef HAVE_IPV6
   if (addr->sa.sa_family == AF_INET6)
     return sizeof(addr->in6);
   else
+#endif
     return sizeof(addr->in); 
 #endif
 }
@@ -438,6 +441,7 @@
   return (a.s_addr & mask.s_addr) == (b.s_addr & mask.s_addr);
 } 
 
+#ifdef HAVE_IPV6
 int is_same_net6(struct in6_addr *a, struct in6_addr *b, int prefixlen)
 {
   int pfbytes = prefixlen >> 3;
@@ -476,12 +480,15 @@
     }
 }
 
+#endif
+ 
 
 /* returns port number from address */
 int prettyprint_addr(union mysockaddr *addr, char *buf)
 {
   int port = 0;
   
+#ifdef HAVE_IPV6
   if (addr->sa.sa_family == AF_INET)
     {
       inet_ntop(AF_INET, &addr->in.sin_addr, buf, ADDRSTRLEN);
@@ -500,6 +507,10 @@
 	}
       port = ntohs(addr->in6.sin6_port);
     }
+#else
+  strcpy(buf, inet_ntoa(addr->in.sin_addr));
+  port = ntohs(addr->in.sin_port); 
+#endif
   
   return port;
 }
